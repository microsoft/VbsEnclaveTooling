// This file was auto-generated by edlcodegen.exe
// Changes to this file may be lost if the file is regenerated.

#![allow(unused)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

use crate::abi::abi_types;
use crate::abi::fb_support::fb_types::code_gen_test::flatbuffer_types;
use crate::implementation::types::*;
use crate::implementation::untrusted::Untrusted;
use edlcodegen_host::host_helpers::call_vtl1_export_from_vtl0;

use edlcodegen_host::EnclaveHandle;
use windows_strings::s;
use widestring::{U16String, U16Str};

pub struct CodeGenTestClass {
    enclave_handle: EnclaveHandle,
}

impl CodeGenTestClass {
    pub fn new(enclave_ptr: *mut core::ffi::c_void) -> Self {
        Self { enclave_handle : EnclaveHandle(enclave_ptr) }
    }

    pub fn FuncWithAllArgs(&self, arg1 : bool, arg2 : Option<&u32>, arg3 : Option<&mut i32>, arg4 : Option<&mut u64>, arg5 : &mut TestStruct1, arg6 : Option<&mut TestStruct2>, arg7 : &mut Vec<TestStruct2>, arg8 : &mut Vec<i16>, arg9 : &mut [U16String;2]) -> Result<i32, edlcodegen_host::AbiError>
    {
        use abi_types::FuncWithAllArgs_0_Args as AbiTypeT;
        use flatbuffer_types::FuncWithAllArgs_0_ArgsT as FlatBufferT;
        let mut abi_type : AbiTypeT = AbiTypeT::default();
        abi_type.m_arg1 = arg1.clone();
        abi_type.m_arg2 = arg2.as_deref().copied();
        abi_type.m_arg3 = arg3.as_deref().copied();
        abi_type.m_arg5 = arg5.clone();
        abi_type.m_arg7 = arg7.to_owned();

        let fb_native : FlatBufferT = abi_type.into();
        let result = call_vtl1_export_from_vtl0::<AbiTypeT, FlatBufferT>(&fb_native, self.enclave_handle.0, s!("FuncWithAllArgs_0_Generated_Stub"))?;
        edlcodegen_host::assign_if_some(arg3, result.m_arg3);
        edlcodegen_host::assign_if_some(arg4, result.m_arg4);
        *arg5 = result.m_arg5;
        edlcodegen_host::assign_if_some(arg6, result.m_arg6);
        *arg7 = result.m_arg7;
        *arg8 = result.m_arg8;
        *arg9 = result.m_arg9;

        Ok(result.m__return_value_)
    }

    pub fn register_vtl0_callbacks<T: Untrusted>(&self) -> Result<(), edlcodegen_host::AbiError>
    {
        use std::string::ToString;
        use flatbuffer_types::AbiRegisterVtl0Callbacks_argsT as FlatBufferT;
        let mut fb_native : FlatBufferT = FlatBufferT::default();
        fb_native.m_callback_addresses = T::callback_addresses().to_vec();
        fb_native.m_callback_names = T::callback_names().iter().map(ToString::to_string).collect();
        call_vtl1_export_from_vtl0::<abi_types::AbiRegisterVtl0Callbacks_args, FlatBufferT>(&fb_native, self.enclave_handle.0, s!("__AbiRegisterVtl0Callbacks_code_gen_test__"))?;
        Ok(())
    }
}
