// This file was auto-generated by edlcodegen.exe
// Changes to this file may be lost if the file is regenerated.

#![allow(unused)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

use crate::abi::abi_types;
use crate::abi::fb_support::fb_types::code_gen_test::flatbuffer_types;
use crate::implementation::types::*;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use crate::alloc::borrow::ToOwned;
use edlcodegen_enclave::enclave_helpers::call_vtl0_callback_from_vtl1;

pub fn FuncWithAllArgs(arg1 : bool, arg2 : Option<&u32>, arg3 : Option<&mut i32>, arg4 : Option<&mut u64>, arg5 : &mut TestStruct1, arg6 : Option<&mut TestStruct2>, arg7 : &mut Vec<TestStruct2>, arg8 : &mut Vec<i16>, arg9 : &mut [widestring::U16String;2]) -> Result<i32, edlcodegen_enclave::AbiError>
{
    use abi_types::FuncWithAllArgs_1_Args as AbiTypeT;
    use flatbuffer_types::FuncWithAllArgs_1_ArgsT as FlatBufferT;
    let mut abi_type : AbiTypeT = AbiTypeT::default();
    abi_type.m_arg1 = arg1.clone();
    abi_type.m_arg2 = arg2.as_deref().copied();
    abi_type.m_arg3 = arg3.as_deref().copied();
    abi_type.m_arg5 = arg5.clone();
    abi_type.m_arg7 = arg7.to_owned();

    let fb_native : FlatBufferT = abi_type.into();
    let result = call_vtl0_callback_from_vtl1::<AbiTypeT, FlatBufferT>(&fb_native, "FuncWithAllArgs_1_Generated_Stub")?;
    edlcodegen_enclave::assign_if_some(arg3, result.m_arg3);
    edlcodegen_enclave::assign_if_some(arg4, result.m_arg4);
    *arg5 = result.m_arg5;
    edlcodegen_enclave::assign_if_some(arg6, result.m_arg6);
    *arg7 = result.m_arg7;
    *arg8 = result.m_arg8;
    *arg9 = result.m_arg9;

    Ok(result.m__return_value_)
}
