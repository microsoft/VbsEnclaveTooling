// This file was auto-generated by edlcodegen.exe
// Changes to this file may be lost if the file is regenerated.

#pragma once
#include <VbsEnclave\HostApp\AbiDefinitions.h>
#include <VbsEnclave\HostApp\DeveloperTypes.h>
#include <VbsEnclaveABI\Host\HostHelpers.h>

namespace CodeGenTest::Trusted::Stubs
{
    using namespace CodeGenTest::DeveloperTypes;

    struct CodeGenTestClass
    {
        CodeGenTestClass(LPVOID enclave) : m_enclave(enclave) {}
        
        HRESULT FuncWithAllArgs(_In_  bool arg1, _In_ const uint32_t* arg2, _Inout_  int32_t* arg3, _Out_  std::unique_ptr<uint64_t>& arg4, _Inout_  TestStruct1& arg5, _Out_  std::unique_ptr<TestStruct2>& arg6, _Inout_  std::vector<TestStruct2>& arg7, _Out_  std::vector<std::int16_t>& arg8, _Out_  std::array<std::wstring, 2>& arg9)
        {
            FlatbuffersDevTypes::FuncWithAllArgs_0_argsT in_flatbufferT {};
            in_flatbufferT.m_arg1 = VbsEnclaveABI::Shared::Converters::ConvertType<decltype(in_flatbufferT.m_arg1)>(arg1);
            in_flatbufferT.m_arg2 = VbsEnclaveABI::Shared::Converters::ConvertType<decltype(in_flatbufferT.m_arg2)>(arg2);
            in_flatbufferT.m_arg3 = VbsEnclaveABI::Shared::Converters::ConvertType<decltype(in_flatbufferT.m_arg3)>(arg3);
            in_flatbufferT.m_arg5 = VbsEnclaveABI::Shared::Converters::ConvertType<decltype(in_flatbufferT.m_arg5)>(arg5);
            in_flatbufferT.m_arg7 = VbsEnclaveABI::Shared::Converters::ConvertType<decltype(in_flatbufferT.m_arg7)>(arg7);
            in_flatbufferT.m_arg9 = VbsEnclaveABI::Shared::Converters::ConvertType<decltype(in_flatbufferT.m_arg9)>(arg9);

            using ParamsT = decltype(in_flatbufferT);
            auto flatbuffer_builder = VbsEnclaveABI::Shared::PackFlatbuffer(in_flatbufferT);
            using ReturnParamsT = FlatbuffersDevTypes::FuncWithAllArgs_0_argsT;
            auto function_result = ReturnParamsT();
            THROW_IF_FAILED((VbsEnclaveABI::HostApp::CallVtl1ExportFromVtl0<ReturnParamsT>(m_enclave, "FuncWithAllArgs_0_Generated_Stub", flatbuffer_builder, function_result)));
            
            auto return_params = VbsEnclaveABI::Shared::Converters::ConvertStruct<FuncWithAllArgs_0_args>(function_result);
            VbsEnclaveABI::Shared::Converters::UpdateParameterValue(return_params.m_arg3, arg3);
            VbsEnclaveABI::Shared::Converters::UpdateParameterValue(return_params.m_arg4, arg4);
            VbsEnclaveABI::Shared::Converters::UpdateParameterValue(return_params.m_arg5, arg5);
            VbsEnclaveABI::Shared::Converters::UpdateParameterValue(return_params.m_arg6, arg6);
            VbsEnclaveABI::Shared::Converters::UpdateParameterValue(return_params.m_arg7, arg7);
            VbsEnclaveABI::Shared::Converters::UpdateParameterValue(return_params.m_arg8, arg8);
            VbsEnclaveABI::Shared::Converters::UpdateParameterValue(return_params.m_arg9, arg9);
            return std::move(return_params.m__return_value_);

        }

        HRESULT RegisterVtl0Callbacks()
        {
            auto lock = m_register_callbacks_lock.lock_exclusive();

            if (m_callbacks_registered)
            {
                return S_OK;
            }

            FlatbuffersDevTypes::AbiRegisterVtl0Callbacks_argsT input {};
            input.callback_addresses.assign(m_callback_addresses.begin(), m_callback_addresses.end());
            input.callback_names.assign(m_callback_names.begin(), m_callback_names.end());
            flatbuffers::FlatBufferBuilder builder = VbsEnclaveABI::Shared::PackFlatbuffer(input);
            using ReturnParamsT = FlatbuffersDevTypes::AbiRegisterVtl0Callbacks_argsT;
            ReturnParamsT out_args {};

            HRESULT hr = VbsEnclaveABI::HostApp::CallVtl1ExportFromVtl0<ReturnParamsT>(
                m_enclave,
                "__AbiRegisterVtl0Callbacks_CodeGenTest__",
                builder,
                out_args);
            RETURN_IF_FAILED(hr);

            if (SUCCEEDED(out_args.m__return_value_))
            {
                m_callbacks_registered = true;
            }

            return out_args.m__return_value_;
        }

        private:
            LPVOID m_enclave{};
            bool m_callbacks_registered{};
            wil::srwlock m_register_callbacks_lock{};
            std::array<uintptr_t, 3> m_callback_addresses{ reinterpret_cast<uintptr_t>(&VbsEnclaveABI::HostApp::AllocateVtl0MemoryCallback),reinterpret_cast<uintptr_t>(&VbsEnclaveABI::HostApp::DeallocateVtl0MemoryCallback), reinterpret_cast<uintptr_t>(&AbiDefinitions::FuncWithAllArgs_1_Generated_Stub) };
            std::array<std::string, 3> m_callback_names{ "VbsEnclaveABI::HostApp::AllocateVtl0MemoryCallback","VbsEnclaveABI::HostApp::DeallocateVtl0MemoryCallback", "CodeGenTest::AbiDefinitions::FuncWithAllArgs_1_Generated_Stub" };
    };
}
