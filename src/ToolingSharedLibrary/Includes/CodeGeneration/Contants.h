// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
#pragma once 
#include <pch.h>
#include <Edl\Structures.h>

using namespace EdlProcessor;

namespace CodeGeneration
{
    static inline constexpr std::string_view c_four_spaces = "    ";

    static inline constexpr std::string_view c_developer_types_header = "DeveloperTypes.h";

    static inline constexpr std::string_view c_trust_vtl1_stubs_header = "Stubs.cpp";

    static inline constexpr std::string_view c_untrusted_vtl0_stubs_header = "Stubs.h";

    static inline constexpr std::string_view c_trusted_vtl1_impl_header = "Implementations.h";

    static inline constexpr std::string_view c_output_folder_for_generated_trusted_functions = R"(VbsEnclave\Enclave)";

    static inline constexpr std::string_view c_output_folder_for_generated_untrusted_functions = R"(VbsEnclave\HostApp)";

    static inline constexpr std::string_view c_output_module_def_file_name = "vbsenclave.def";

    static inline constexpr std::string_view c_autogen_header_string =
R"(// This file was auto-generated by VbsEnclaveTooling.exe
// Changes to this file may be lost if the file is regenerated.
)";

    static inline constexpr std::string_view c_pragma_pack = R"(#pragma pack(push, 1))";

    static inline constexpr std::string_view c_pragma_pop = R"(#pragma pack(pop))";

    static inline constexpr std::string_view c_array_initializer = "std::array<";

    static inline constexpr std::string_view c_in_annotation = "_In_";

    static inline constexpr std::string_view c_inout_annotation = "_Inout_";

    static inline constexpr std::string_view c_out_annotation = "_Out_";

    static inline constexpr std::string_view c_return_variable_name = "result";

    static inline constexpr std::string_view c_generated_stub_name = "\"{}_Generated_Stub\"";

    static inline constexpr std::string_view c_parameter_container_type = "ParameterContainer<{}>";

    static inline constexpr std::string_view c_enclave_string_type = "EnclaveString";

    static inline constexpr std::string_view c_parameter_container = "auto parameters = ParameterContainer<{}>( {} );";

    // Ending {} for comma or empty string
    static inline constexpr std::string_view c_parameter_type_comma_in_back = "{}{}";

    static inline constexpr std::string_view c_parameter_type_comma_in_front = "{}{}";

    // Ending {} for comma or empty string
    static inline constexpr std::string_view c_function_actual_parameter = "{}{}"; //FunctionParameter<{}>{{ {} }}{}
        
    // Using a R("...") that contains a " character with std::format ends up adding a \" to the string.
    // instead of the double quote itself. So, as a work around we'll use the old style of declaring a multi line string.
    static inline constexpr std::string_view c_vtl0_class_start_of_file = 
"\
#pragma once\n\
#include <VbsEnclaveABI\\Host\\HostHelpers.h>\n\
#include \"DeveloperTypes.h\"\
\n\
using namespace VbsEnclaveABI;\n\
using namespace VbsEnclaveABI::Shared;\n\
using namespace VbsEnclaveABI::HostApp;\n\
using namespace DeveloperTypes;\n\
\n\
";

    static inline constexpr std::string_view c_vtl0_class_hostapp_namespace = R"(
namespace {}
{{
    namespace VTL0_Stubs
    {{
{}
    }}
}}
)";

    // Using a R("...") that contains a " character with std::format ends up adding a \" to the string.
    // instead of the double quote itself. So, as a work around we'll use the old style of declaring a multi line string.
    static inline constexpr std::string_view c_vtl1_enclave_stub_includes = 
"\
#pragma once\n\
#include <VbsEnclaveABI\\Enclave\\EnclaveHelpers.h>\n\
#include \"Implementations.h\"\n\
\n\
using namespace VbsEnclaveABI;\n\
using namespace VbsEnclaveABI::Shared;\n\
using namespace VbsEnclaveABI::Enclave;\n\
using namespace DeveloperTypes;\n\
\n\
";

    static inline constexpr std::string_view c_vtl1_enclave_stub_namespace = R"(
// START: DO NOT MODIFY: For internal abi usage
namespace VbsEnclaveABI::Enclave::VTL0CallBackHelpers
{{
LPENCLAVE_ROUTINE s_vtl0_allocation_function = nullptr;
LPENCLAVE_ROUTINE s_vtl0_deallocation_function = nullptr;
wil::srwlock s_vtl0_function_table_lock {{}};
bool s_are_functions_registered {{}};
std::unordered_map<std::uint32_t, std::uint64_t> s_vtl0_function_table{{}};
}}
namespace VbsEnclaveABI::Enclave::MemoryChecks
{{
LPCVOID s_enclave_memory_begin = nullptr; // inclusive
LPCVOID s_enclave_memory_end = nullptr;   // exclusive
std::atomic<bool> s_memory_bounds_calculated = {{}};
}}
// END: DO NOT MODIFY: For internal abi usage
namespace {}
{{
    namespace VTL1_Stubs
    {{
{}
    }}
}}
)";

    static inline constexpr std::string_view c_outer_abi_function = R"(
{} CALLBACK {}_Generated_Stub(void* function_context)
try
{{
{}
LOG_IF_FAILED(hr);
return HRESULT_TO_PVOID(hr);
}}
catch (...)
{{
HRESULT hr = wil::ResultFromCaughtException();
LOG_IF_FAILED(hr);
return HRESULT_TO_PVOID(hr);
}}
)";

    // This body is specific to the developer function
    static inline constexpr std::string_view c_inner_abi_function = 
R"(using ParamsT = {};
using ReturnParamsT = {};
{})";

    // This body is specific to the developer function
    static inline constexpr std::string_view c_initial_caller_function_body = R"(
{}
{{
{}

using ParamsT = decltype(parameters);
using ReturnParamsT = {};
{}
auto function_result = FunctionResult<ReturnParamsT>();
{}
{}
}}
)";

    static inline constexpr std::string_view c_vtl0_call_to_vtl1_export =
R"(THROW_IF_FAILED((CallVtl1ExportFromVtl0<ParamsT, ReturnParamsT>(m_enclave, {}, parameters, function_result)));)";

    static inline constexpr std::string_view c_vtl1_call_to_vtl1_export =
R"(HRESULT hr = CallVtl1ExportFromVtl1<ParamsT, ReturnParamsT, decltype(AbiDefinitions::{}_Abi_Impl)>(function_context, AbiDefinitions::{}_Abi_Impl);)";

    static inline constexpr std::string_view c_vtl0_call_to_vtl0_callback =
R"(HRESULT hr = CallVtl0CallbackImplFromVtl0<ParamsT, ReturnParamsT, decltype({}_Abi_Impl)>(function_context, {}_Abi_Impl);)";

    static inline constexpr std::string_view c_vtl1_call_to_vtl0_callback =
R"(THROW_IF_FAILED((CallVtl0CallbackFromVtl1<ParamsT, ReturnParamsT>({}U, vtl0_parameters, function_result)));)";

    // Using a R("...") that contains a " character with std::format ends up adding a \" to the string.
    // instead of the double quote itself. So, as a work around we'll use the old style of declaring a multi line string.
    static inline constexpr std::string_view c_vtl1_enclave_func_impl_start_of_file =
"\
#pragma once\n\
#include <VbsEnclaveABI\\Enclave\\EnclaveHelpers.h>\n\
#include \"DeveloperTypes.h\"\n\
\n\
using namespace VbsEnclaveABI;\n\
using namespace VbsEnclaveABI::Shared;\n\
using namespace VbsEnclaveABI::Enclave;\n\
using namespace DeveloperTypes;\n\
\n\
";

    static inline constexpr std::string_view c_vtl1_enclave_func_impl_namespace = R"(
namespace {}
{{
    namespace VTL1_Declarations
    {{
{}
    }}

    namespace VTL0_Callbacks
    {{
{}
    }}

    namespace AbiDefinitions
    {{
{}
    }}
}}
)";

    // Using a R("...") that contains a " character with std::format ends up adding a \" to the string.
    // instead of the double quote itself. So, as a work around we'll use the old style of declaring a multi line string.
    static inline constexpr std::string_view c_developer_types_start_of_file = 
"\
{}\n\
#pragma once\n\
#include <VbsEnclaveABI\\Shared\\VbsEnclaveAbiBase.h>\n\
\n\
";

    static inline constexpr std::string_view c_developer_types_namespace = R"(
namespace DeveloperTypes
{{
{}
}}
)";

    static inline constexpr std::string_view c_enclave_def_file_content = R"(
{}
LIBRARY

    EXPORTS
{}
)";

    static inline constexpr std::string_view c_vtl0_class_constructor = R"(
{}(LPVOID enclave) : m_enclave(enclave)
{{
}}
)";

    static inline constexpr std::string_view c_vtl0_class_add_callback_member = R"(
private:
    LPVOID m_enclave{{}};
    bool m_callbacks_registered{{}};
    wil::srwlock m_register_callbacks_lock{{}};
    std::array<uint64_t, {}> m_callbacks{{ {} }};
)";

    static inline constexpr std::string_view c_setup_return_params_tuple = R"(
auto& return_params_tuple = function_result.m_returned_parameters->m_members;
{}
{}
)";

    static inline constexpr std::string_view c_return_value_to_initial_caller = R"(
constexpr size_t tuple_size = std::tuple_size<std::remove_reference_t<decltype(return_params_tuple)>>::value;
return std::get<tuple_size - 1>(return_params_tuple); // the last parameter is always the function return value.
)";

    static inline constexpr std::string_view c_scope_ending_brackets = "}";

    static inline constexpr std::string_view c_vtl1_register_callback_function = "VTL0CallBackHelpers::AddVtl0FunctionsToTable";

    static inline constexpr std::string_view c_generated_abi_impl_function = R"(
static inline void {}_Abi_Impl{}
{{
{}
}}
)";

    static inline constexpr std::string_view c_generated_abi_impl_function_with_return_value = R"(
static inline {} {}_Abi_Impl{}
{{
{}
}}
)";

    static inline constexpr std::string_view c_generated_internal_abi_impl_function = R"(
void {}_Abi_Impl{}
{{
{}
}}
)";

    static inline constexpr std::string_view c_abi_func_return_value = R"(
auto result = {}({});
{}
)";

    static inline constexpr std::string_view c_abi_func_return_null_when_void = R"(
{}({});
{}
)";

    static inline constexpr std::string_view c_copy_parameters_into_tuple = R"(
using ReturnParamsT = ParameterContainer<{}>;

auto new_return_params = ReturnParamsT({});
auto& return_params_tuple = new_return_params.m_members;

// Perform any special copies. E.g if size/count attributes were used in the edl file.
{}
void* new_return_params_ptr = AllocateMemory(sizeof(ReturnParamsT));
memcpy(new_return_params_ptr, &new_return_params, sizeof(ReturnParamsT));
*return_params = reinterpret_cast<ReturnParamsT*>(new_return_params_ptr);

)";
    static inline constexpr std::string_view c_vtl0_call_developer_impl = "{}";

    static inline constexpr std::string_view c_vtl1_call_developer_impl = "VTL1_Declarations::{}";

    static inline constexpr std::string_view c_copy_non_pointer_value_to_param = R"(
{} = {};)";

    static inline constexpr std::string_view c_std_get_tuple_value = "std::get<{}>(return_params_tuple)";

    static inline constexpr std::string_view c_std_get_vtl1_input_tuple_value = "std::get<{}>(vtl0_parameters->m_members)";

    static inline constexpr std::string_view c_allocate_memory_callback_to_address = "reinterpret_cast<uint64_t>(&VbsEnclaveABI::HostApp::AllocateVtl0Memory)";

    static inline constexpr std::string_view c_deallocate_memory_callback_to_address = ",reinterpret_cast<uint64_t>(&VbsEnclaveABI::HostApp::DeallocateVtl0Memory)";

    static inline constexpr std::string_view c_callback_to_address = ", reinterpret_cast<uint64_t>(&{}_Generated_Stub)";

    static inline constexpr std::string_view c_untrusted_function_name = "{}_callback";

    static inline constexpr std::string_view c_exported_function_in_module = 
R"(     {}_Generated_Stub
)";

    static inline constexpr std::string_view c_empty_return = "return;";

    static inline constexpr std::string_view c_abi_return_param_declaration = "{}_Out_ {}** return_params";

    static inline constexpr size_t c_number_of_abi_callbacks = 2;

    static inline constexpr std::string_view c_vtl0_enclave_class_name = "{}Wrapper";

    static inline constexpr std::string_view c_vtl0_enclave_class_public_keyword = "\npublic:\n";

    static inline constexpr std::string_view c_vtl0_enclave_class_private_keyword = "\nprivate:\n";

    static inline constexpr std::string_view c_vtl1_copy_input_params_to_vtl0_buffer = R"(
ParamsT* vtl0_parameters = nullptr;
PerformVTL0AllocationAndCopy(&vtl0_parameters, &parameters, sizeof(parameters));
{}
)";

    static inline constexpr std::string_view c_copy_out_param_into_vtl0_heap_from_vtl1 = R"(
PerformVTL0AllocationAndCopy({}, *{}, {});
)";

    static inline constexpr std::string_view c_copy_out_param_into_vtl0_heap = R"(
PerformVTL0AllocationAndCopy({}, *{}, {});
)";

    static inline constexpr std::string_view c_copy_in_out_param_into_vtl0_heap = R"(
PerformVTL0AllocationAndCopy(&{}, {}, {});
)";

    static inline constexpr std::string_view c_copy_in_param_into_vtl0_heap_from_vtl1 = R"(
PerformVTL0AllocationAndCopy(&{}, {}, {});
)";

    static inline constexpr std::string_view c_copy_out_param_into_vtl1_heap = R"(
PerformVTL1AllocationAndCopy({}, *{}, {});
)";

    static inline constexpr std::string_view c_copy_in_out_param_into_vtl1_heap = R"(
PerformVTL1AllocationAndCopy(&{}, {}, {});
)";

    static inline constexpr std::string_view c_copy_value_param_function = R"(
UpdateValue({}, {}, {});
)";

    static inline constexpr std::string_view c_copy_out_param_without_allocation = R"(
UpdateOutParamPtr({}, *{}, {});
)";

    static inline constexpr std::string_view c_copy_in_out_param_without_allocation = R"(
UpdateInOutParamPtr({}, {}, {});
)";

    static inline constexpr std::string_view c_deallocate_vtl0_out_param_mem_from_vtl0 = R"(
LOG_IF_FAILED(Shared::DeallocateMemory(*{}));
)";

    static inline constexpr std::string_view c_deallocate_vtl0_in_out_mem_from_vtl0 = R"(
LOG_IF_FAILED(Shared::DeallocateMemory({}));
)";

    static inline constexpr std::string_view c_deallocate_vtl0_out_mem_from_vtl1 = R"(
LOG_IF_FAILED(DeallocateVtl0Memory(*{}));
)";

    static inline constexpr std::string_view c_deallocate_vtl0_in_out_mem_from_vtl1 = R"(
LOG_IF_FAILED(DeallocateVtl0Memory({}));
)";

    static inline constexpr std::string_view c_copy_value_func_size_t_param = "sizeof({})";

    static inline constexpr std::string_view c_count_statement = "sizeof({}) * {}";

    static inline constexpr std::string_view c_void_ptr = "void*";

    static inline constexpr std::string_view c_static_void_ptr = "static inline void*";

    static inline constexpr std::string_view c_static_declaration = "static {} {} {};\n";

    static inline constexpr std::string_view c_function_declaration = "{} {} {};\n";

    static inline constexpr std::string_view c_void_function_declaration = "void {} {}{};\n";

    static inline constexpr std::string_view c_static_keyword = "static ";

    static inline constexpr std::string_view c_hresult_type = "HRESULT ";

    static inline constexpr std::string_view c_vtl0_abi_boundary_functions_comment = R"(
/***********************************************
 *    VTL0 Generated ABI Boundary Callbacks    *
************************************************/
)";

    static inline constexpr std::string_view c_vtl1_abi_boundary_functions_comment = R"(
/***********************************************
 *    VTL1 Generated ABI Boundary Callbacks    *
************************************************/
)";

    static inline constexpr std::string_view c_vtl0_abi_impl_callback_functions_comment = R"(
/*****************************************************
 *    VTL0 Generated ABI Implementation Callbacks    *
******************************************************/
)";

    static inline constexpr std::string_view c_vtl1_abi_impl_functions_comment = R"(
/*****************************************************
 *    VTL0 Generated ABI Implementation Callbacks    *
******************************************************/
)";

    static inline constexpr std::string_view c_vtl0_developer_declaration_functions_comment = R"(
/*****************************************************
 *    VTL0 Generated Developer Method Declarations   *
******************************************************/
)";

    static inline constexpr std::string_view c_vtl1_developer_declaration_functions_comment = R"(
/*******************************************************
 *    VTL1 Generated Developer Function Declarations   *
********************************************************/
)";

    static inline constexpr std::string_view c_vtl0_side_of_vtl1_developer_impl_functions_comment = R"(
/************************************************************
 *    VTL0 Side Of VTL1 Developer Function Implementations  *
*************************************************************/
)";

    static inline constexpr std::string_view c_vtl1_side_of_vtl0_developer_callback_functions_comment = R"(
/**********************************************************
 *    VTL1 Side Of VTL0 Developer Method Implementations  *
***********************************************************/
)";

    static inline constexpr std::string_view c_vtl0_register_callbacks_abi_function = R"(
HRESULT RegisterVtl0Callbacks()
{{
auto lock = m_register_callbacks_lock.lock_exclusive();

if (m_callbacks_registered)
{{
return S_OK;;
}}

HRESULT hr = VbsEnclaveABI::HostApp::AbiRegisterVtl0Callbacks(m_enclave, m_callbacks);

if (SUCCEEDED(hr))
{{
m_callbacks_registered = true;
}}

return hr;
}}
)";

    static inline constexpr std::string_view c_vtl1_register_callbacks_abi_export_name = "__AbiRegisterVtl0Callbacks__";

    static inline constexpr std::string_view c_vtl1_register_callbacks_abi_export = R"(
void* CALLBACK __AbiRegisterVtl0Callbacks__(void* function_context)
try
{{
using ParamsT = ParameterContainer<EnclaveParameters>;
using ReturnParamsT = ParameterContainer<HRESULT>;
HRESULT hr = CallVtl1ExportFromVtl1<ParamsT, ReturnParamsT, decltype(RegisterVtl0Callbacks)>(function_context, RegisterVtl0Callbacks);
LOG_IF_FAILED(hr);
return HRESULT_TO_PVOID(hr);
}}
catch (...)
{{
HRESULT hr = wil::ResultFromCaughtException();
LOG_IF_FAILED(hr);
return HRESULT_TO_PVOID(hr);
}}
)";
}

