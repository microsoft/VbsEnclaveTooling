// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
#pragma once 
#include <pch.h>
#include <Edl\Structures.h>

using namespace EdlProcessor;

namespace CodeGeneration
{
    static inline constexpr std::string_view c_four_spaces = "    ";

    static inline constexpr std::string_view c_types_header_name = "Types.h";

    static inline constexpr std::string_view c_trust_vtl1_stubs_header = "Stubs.cpp";

    static inline constexpr std::string_view c_untrusted_vtl0_stubs_header = "Stubs.h";

    static inline constexpr std::string_view c_trusted_vtl1_impl_header = "Implementations.h";

    static inline constexpr std::string_view c_enclave_exports_source = "Exports.cpp";

    static inline constexpr std::string_view c_output_folder_for_generated_trusted_functions = R"(VbsEnclave\Enclave)";

    static inline constexpr std::string_view c_output_folder_for_generated_untrusted_functions = R"(VbsEnclave\HostApp)";

    static inline constexpr std::string_view c_abi_boundary_func_declaration = "    __declspec(dllexport) void* {}(void* function_context);\n";

    static inline constexpr std::string_view c_abi_boundary_func_declaration_for_stubs = "        void* {}(void* function_context);\n";

    static inline constexpr std::string_view c_stubs_header_for_enclave_exports = "{}_StubsForExports.h";

    static inline constexpr std::string_view c_autogen_header_string =
R"(// This file was auto-generated by edlcodegen.exe
// Changes to this file may be lost if the file is regenerated.
)";

    static inline constexpr std::string_view c_array_initializer = "std::array<{}, {}>";

    static inline constexpr std::string_view c_in_annotation = "_In_";

    static inline constexpr std::string_view c_inout_annotation = "_Inout_";

    static inline constexpr std::string_view c_out_annotation = "_Out_";

    static inline constexpr std::string_view c_return_variable_name = "result";

    static inline constexpr std::string_view c_generated_stub_name = "\"{}_Generated_Stub\"";

    static inline constexpr std::string_view c_generated_stub_name_no_quotes = "{}_Generated_Stub";

    static inline constexpr std::string_view c_vtl1_enforce_mem_restriction_func = R"(
        namespace Abi::Runtime
        {
            static void EnforceMemoryRestriction()
            {
                if (ENABLE_ENCLAVE_RESTRICT_CONTAINING_PROCESS_ACCESS)
                {
                    VbsEnclaveABI::Enclave::EnableEnclaveRestrictContainingProcessAccessOnce();
                }
            }
        }
)";

    static inline constexpr std::string_view c_enforce_memory_restriction_call =
        R"(Abi::Runtime::EnforceMemoryRestriction();)";

    static inline constexpr std::string_view c_outer_abi_function = R"(
        {} {}_Generated_Stub(void* function_context)
        try
        {{
            {}
            LOG_IF_FAILED(hr);
            return ABI_HRESULT_TO_PVOID(hr);
        }}
        catch (...)
        {{
            HRESULT hr = wil::ResultFromCaughtException();
            LOG_IF_FAILED(hr);
            return ABI_HRESULT_TO_PVOID(hr);
        }}
)";

    // This body is specific to the developer function
    static inline constexpr std::string_view c_inner_abi_function =
        R"(using AbiTypeT = {}::Abi::Types::{};
            using FlatBufferT = FlatbufferTypes::{}T;
            {}
            {})";

    // This body is specific to the developer function
    static inline constexpr std::string_view c_stub_function_body = R"(
        {}
        {{
{}
        }}
)";

    static inline constexpr std::string_view c_vtl0_call_to_vtl1_export =
"\n            VbsEnclaveABI::HostApp::CallVtl1ExportFromVtl0<void>(in_flatbufferT, m_enclave, {});";

    static inline constexpr std::string_view c_vtl0_call_to_vtl1_export_with_return =
"\n            auto return_params = VbsEnclaveABI::HostApp::CallVtl1ExportFromVtl0<{}::Abi::Types::{}>(in_flatbufferT, m_enclave, {});";

    static inline constexpr std::string_view c_vtl1_call_to_vtl1_export =
R"(HRESULT hr = VbsEnclaveABI::Enclave::CallVtl1ExportFromVtl1<AbiTypeT, FlatBufferT>(Trusted::Implementation::{}, function_context);)";

    static inline constexpr std::string_view c_vtl0_call_to_vtl0_callback =
R"(HRESULT hr = VbsEnclaveABI::HostApp::CallVtl0CallbackImplFromVtl0<AbiTypeT, FlatBufferT>(Untrusted::Implementation::{}, function_context);)";

    static inline constexpr std::string_view c_vtl1_call_to_vtl0_callback =
"\n            VbsEnclaveABI::Enclave::CallVtl0CallbackFromVtl1<void>(in_flatbufferT, {});";

    static inline constexpr std::string_view c_vtl1_call_to_vtl0_callback_with_return =
"\n            auto return_params = VbsEnclaveABI::Enclave::CallVtl0CallbackFromVtl1<{}::Abi::Types::{}>(in_flatbufferT, {});";

    static inline constexpr std::string_view c_generated_callback_in_namespace = "\"{}::Abi::Definitions::{}_Generated_Stub\"";

    static inline constexpr std::string_view c_vtl1_sdk_pragma_statement = R"(#pragma comment(linker, "/include:{}")
)";

    static inline constexpr std::string_view c_vtl1_export_functions_source_file =
R"({}
#pragma once
#include <wil/enclave/wil_for_enclaves.h>
#include <VbsEnclave\Enclave\Abi\Definitions.h>

// Explicitly add linker statements so the generated export functions created by the code generator 
// can be exported when used to create a static lib.
{}{}
)";

    static inline constexpr std::string_view c_enclave_export_func_definition = R"(
extern "C" __declspec(dllexport) void* {}(void* function_context) 
{{
    return {}::Abi::Definitions::{}(function_context);
}}
)";

    static inline constexpr std::string_view c_developer_types_file = 
R"({}
#pragma once
#include <VbsEnclaveABI\Shared\VbsEnclaveAbiBase.h>

namespace {}::Types
{{
{}
}}

)";

    static inline constexpr std::string_view c_abi_function_types_file =
R"({}
#pragma once
#include <VbsEnclave\{}\Implementation\Types.h>
#include <VbsEnclave\{}\Abi\FlatbufferTypes.h>

namespace {}::Abi::Types
{{
    using namespace {}::Types;
{}
}}
)";

    static inline constexpr std::string_view c_abi_struct_metadata_file =
R"({}
#pragma once
#include <VbsEnclave\{}\Abi\AbiTypes.h>
#include <VbsEnclaveABI\Shared\ConversionHelpers.h>

namespace VbsEnclaveABI::Shared::Converters
{{
{}
}}
)";

    static inline constexpr std::string_view c_vtl0_untrusted_abi_stubs_address_info =
R"(std::array<uintptr_t, {}> m_callback_addresses{{ {} }};
            std::array<std::string, {}> m_callback_names{{ {} }};)";

    static inline constexpr std::string_view c_allocate_memory_callback_to_address = "reinterpret_cast<uintptr_t>(&VbsEnclaveABI::HostApp::AllocateVtl0MemoryCallback)";

    static inline constexpr std::string_view c_deallocate_memory_callback_to_address = ",reinterpret_cast<uintptr_t>(&VbsEnclaveABI::HostApp::DeallocateVtl0MemoryCallback)";

    static inline constexpr std::string_view c_allocate_memory_callback_to_name = "\"VbsEnclaveABI::HostApp::AllocateVtl0MemoryCallback\"";

    static inline constexpr std::string_view c_deallocate_memory_callback_to_name = ",\"VbsEnclaveABI::HostApp::DeallocateVtl0MemoryCallback\"";

    static inline constexpr std::string_view c_callback_to_address = ", reinterpret_cast<uintptr_t>(&Abi::Definitions::{}_Generated_Stub)";

    static inline constexpr std::string_view c_callback_to_name = ", {}";

    static inline constexpr std::string_view c_exported_function_in_module = 
R"(     {}_Generated_Stub
)";

    static inline constexpr size_t c_number_of_abi_callbacks = 2;

    static inline constexpr std::string_view c_vtl0_enclave_class_name = "{}Wrapper";

    static inline constexpr std::string_view c_void_ptr = "void*";

    static inline constexpr std::string_view c_static_void_ptr = "static inline void*";

    static inline constexpr std::string_view c_function_declaration = R"(
        {} {}{};
)";

    static inline constexpr std::string_view c_static_keyword = "static ";

    static inline constexpr std::string_view c_vtl0_register_callbacks_abi_function = R"(
        HRESULT RegisterVtl0Callbacks()
        {{
            auto lock = m_register_callbacks_lock.lock_exclusive();

            if (m_callbacks_registered)
            {{
                return S_OK;
            }}

            FlatbufferTypes::AbiRegisterVtl0Callbacks_argsT in_flatbufferT {{}};
            in_flatbufferT.m_callback_addresses.assign(m_callback_addresses.begin(), m_callback_addresses.end());
            in_flatbufferT.m_callback_names.assign(m_callback_names.begin(), m_callback_names.end());
            auto return_params = VbsEnclaveABI::HostApp::CallVtl1ExportFromVtl0<VbsEnclaveABI::Shared::Converters::AbiRegisterVtl0Callbacks_args>(in_flatbufferT, m_enclave, {});

            if (SUCCEEDED(return_params.m__return_value_))
            {{
                m_callbacks_registered = true;
            }}

            return return_params.m__return_value_;
        }}
)";

    static inline constexpr std::string_view c_vtl1_register_callbacks_abi_export_name = "__AbiRegisterVtl0Callbacks_{}__";

    static inline constexpr std::string_view c_vtl1_register_callbacks_abi_export = R"(
        void* {}(void* function_context)
        try
        {{
            Abi::Runtime::EnforceMemoryRestriction();
            HRESULT hr = VbsEnclaveABI::Enclave::CallVtl1ExportFromVtl1<VbsEnclaveABI::Shared::Converters::AbiRegisterVtl0Callbacks_args, FlatbufferTypes::AbiRegisterVtl0Callbacks_argsT>(VbsEnclaveABI::Enclave::RegisterVtl0Callbacks, function_context);
            LOG_IF_FAILED(hr);
            return ABI_HRESULT_TO_PVOID(hr);
        }}
        catch (...)
        {{
            HRESULT hr = wil::ResultFromCaughtException();
            LOG_IF_FAILED(hr);
            return ABI_HRESULT_TO_PVOID(hr);
        }}
)";

    static inline constexpr std::string_view c_vtl1_trusted_func_declarations_header =
R"({}
#pragma once
#include <VbsEnclave\Enclave\Implementation\Types.h>
#include <VbsEnclaveABI\Enclave\EnclaveHelpers.h>

namespace {}
{{
    namespace Trusted::Implementation
    {{
        using namespace {}::Types;
        {}
    }};
}}
)";

    static inline constexpr std::string_view c_vtl0_trusted_header = 
R"({}
#pragma once
#include <VbsEnclave\HostApp\Abi\Definitions.h>
#include <VbsEnclave\HostApp\Implementation\Types.h>
#include <VbsEnclaveABI\Host\HostHelpers.h>
#include <VbsEnclaveABI\Shared\ConversionHelpers.h>

namespace {}::Trusted::Stubs
{{
    using namespace {}::Types;

    struct {}
    {{
        {}(LPVOID enclave) : m_enclave(enclave) {{}}
        {}
        private:
            LPVOID m_enclave{{}};
            bool m_callbacks_registered{{}};
            wil::srwlock m_register_callbacks_lock{{}};
            {}
    }};
}}
)";

    static inline constexpr std::string_view c_vtl1_untrusted_stubs_header_template =
R"({}
#pragma once
#include <VbsEnclave\Enclave\Abi\TypeMetadata.h>
#include <VbsEnclaveABI\Enclave\EnclaveHelpers.h>

namespace {}
{{
    namespace Untrusted::Stubs
    {{
        using namespace {}::Types;
        {}
    }};
}}
)";

    static inline constexpr std::string_view c_vtl0_untrusted_impl_header_template =
R"({}
#pragma once
#include <VbsEnclave\HostApp\Implementation\Types.h>
#include <VbsEnclaveABI\Host\HostHelpers.h>

namespace {}
{{
    namespace Untrusted::Implementation
    {{
        using namespace {}::Types;
        {}
    }};
}}
)";
    
    static inline constexpr std::string_view c_vtl1_abi_definitions_includes =
R"(#include <VbsEnclave\Enclave\Implementation\Trusted.h>
#include <VbsEnclave\Enclave\Abi\TypeMetadata.h>
)";

    static inline constexpr std::string_view c_vtl0_abi_definitions_includes =
R"(#include <VbsEnclave\HostApp\Implementation\Untrusted.h>
#include <VbsEnclave\HostApp\Abi\TypeMetadata.h>
)";

    static inline constexpr std::string_view c_abi_definitions_stubs_header_template =
R"({}
#pragma once
{}

namespace {}
{{
    namespace Abi::Definitions
    {{
        {}
    }};
}}
)";

    static inline constexpr std::string_view c_update_inout_and_out_param_statement = "\n            VbsEnclaveABI::Shared::Converters::UpdateParameterValue(return_params.m_{}, {});";

    static inline constexpr std::string_view c_parameter_conversion_statement =
"\n            in_flatbufferT.m_{} = VbsEnclaveABI::Shared::Converters::ConvertType<decltype(in_flatbufferT.m_{})>({});";

    static inline constexpr std::string_view c_pack_params_to_flatbuffer_call =
"            FlatbufferTypes::{}T in_flatbufferT {{}};";

    static inline constexpr std::string_view c_return_value_back_to_initial_caller_with_move =
"\n            return std::move(return_params.m__return_value_);";

    static inline constexpr std::string_view c_function_args_struct = "{}_args";

    static inline constexpr std::string_view c_struct_metadata_field_ptr = "&{}::{}::{}::{}{}";

    static inline constexpr std::string_view c_flatbuffer_field_ptr = "&{}::FlatbufferTypes::{}T::{}{}";

    static inline constexpr std::string_view c_struct_meta_data_outline = 
R"(    template <>
    struct StructMetadata<{}>
    {{
        static constexpr auto members = std::make_tuple({});
    }};

)";

    static inline constexpr std::string_view c_abi_flatbuffer_register_callbacks_metadata =
R"(    template <>
    struct StructMetadata<{}::FlatbufferTypes::AbiRegisterVtl0Callbacks_argsT>
    {{
        using CallbackArgs = {}::FlatbufferTypes::AbiRegisterVtl0Callbacks_argsT;
        static constexpr auto members = std::make_tuple(&CallbackArgs::m_callback_addresses, &CallbackArgs::m_callback_names, &CallbackArgs::m__return_value_);
    }};
)";

    static inline constexpr std::string_view c_statements_for_developer_struct = "    struct {};\n";
}

