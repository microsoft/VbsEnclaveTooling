// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
#pragma once 
#include <pch.h>
#include <Edl\Structures.h>

using namespace EdlProcessor;

namespace CodeGeneration
{
    static inline constexpr std::string_view c_four_spaces = "    ";

    static inline constexpr std::string_view c_developer_types_header = "EnclaveDeveloperTypes.h";

    static inline constexpr std::string_view c_trust_vtl1_stubs_header = "VTL1_Stubs.cpp";

    static inline constexpr std::string_view c_untrusted_vtl0_stubs_header = "VTL0_Stubs.h";

    static inline constexpr std::string_view c_trusted_vtl1_impl_header = "VTL1_Implementations.h";

    static inline constexpr std::string_view c_parameter_verifier_header = "ParameterVerifiers.h";

    static inline constexpr std::string_view c_output_folder_for_generated_trusted_functions = R"(VbsEnclaveGenerated_{}\Enclave)";

    static inline constexpr std::string_view c_output_folder_for_generated_untrusted_functions = R"(VbsEnclaveGenerated_{}\HostApp)";

    static inline constexpr std::string_view c_output_folder_for_shared_files = R"(VbsEnclaveGenerated_{}\Shared)";

    static inline constexpr std::string_view c_autogen_header_string =
R"(// This file was auto-generated by VbsEnclaveTooling.exe
// Changes to this file may be lost if the file is regenerated.
)";

    static inline constexpr std::string_view c_pragma_pack = R"(#pragma pack(push, 1))";

    static inline constexpr std::string_view c_pragma_pop = R"(#pragma pack(pop))";

    static inline constexpr std::string_view c_array_initializer = "std::array<";

    static inline constexpr std::string_view c_in_annotation = "_In_";

    static inline constexpr std::string_view c_inout_annotation = "_Inout_";

    static inline constexpr std::string_view c_out_annotation = "_Out_";

    static inline constexpr std::string_view c_const_value = "const";

    static inline constexpr std::string_view c_void_type_function_parameter = "__VoidType__";

    static inline constexpr std::string_view c_generated_stub_name = "\"{}_Generated_Stub\"";

    static inline constexpr std::string_view c_abi_impl_function_return_line = "return {}{};";

    static inline constexpr std::string_view c_developer_impl_namespace = "VTL1_Implementations::DeveloperDeclarations";

    static inline constexpr std::string_view c_parameter_container_type = "ParameterContainer<{}>";

    static inline constexpr std::string_view c_parameter_container = "ParameterContainer<{}> parameters( {} );";

    //Ending {} for comma or empty string
    static inline constexpr std::string_view c_function_parameter_type = "FunctionParameter<{}>{}";

    //Ending {} for comma or empty string
    static inline constexpr std::string_view c_function_tuple_definition = "FunctionParameter<{}>{{ {} }}{}";
        
    // Using a R("...") that contains a " character with std::format ends up adding a \" to the string.
    // instead of the double quote itself. So, as a work around we'll use the old style of declaring a multi line string.
    static inline constexpr std::string_view c_vtl0_class_start_of_file = 
"\n\
#pragma once\n\
#include <VbsEnclaveABI\\Host\\HostHelpers.h>\n\
#include \"..\\Shared\\EnclaveDeveloperTypes.h\"\n\
\n\
using namespace VbsEnclaveABI;\n\
using namespace EnclaveDeveloperTypes;\n\
\n\
";

    static inline constexpr std::string_view c_vtl0_class_hostapp_namespace = R"(
namespace VbsEnclaveGenerated_{}
{{
    namespace HostApp
    {{
        namespace VTL0_Stubs
        {{
// Start of enclave class with stubs

{}
// End of enclave class with stubs
        }}
    }}
}}
)";

    // Note: the '{}' within std::decay_t<decltype({}) is used to retrieve the type of the return value at run time
    static inline constexpr std::string_view c_from_class_call_vtl1_stub_with_result = R"(
{{
    // Add function parameters tuple
    {}

    using FunctionParams = std::decay_t<decltype(parameters)>;

    return CallVtl1StubWithResult<{}, FunctionParams>(m_enclave, {}, parameters);
}}
)";

    static inline constexpr std::string_view c_from_class_call_vtl1_stub_no_result = R"(
{{
    // Add function parameters tuple
    {}

    using FunctionParams = std::decay_t<decltype(parameters)>;

    // Call function with generated name
    CallVtl1StubNoResult<FunctionParams>(m_enclave, {}, parameters);
}}
)";

    // Using a R("...") that contains a " character with std::format ends up adding a \" to the string.
    // instead of the double quote itself. So, as a work around we'll use the old style of declaring a multi line string.
    static inline constexpr std::string_view c_vtl1_enclave_stub_start_of_file = 
"\n\
#pragma once\n\
#include <VbsEnclaveABI\\Enclave\\EnclaveHelpers.h>\n\
#include \"VTL1_Implementations.h\"\n\
#include \"ParameterVerifiers.h\"\n\
\n\
using namespace VbsEnclaveABI;\n\
using namespace EnclaveDeveloperTypes;\n\
\n\
";

    static inline constexpr std::string_view c_vtl1_enclave_stub_namespace = R"(
namespace VbsEnclaveGenerated_{}
{{
    namespace Enclave
    {{
        namespace VTL1_Stubs
        {{
// Start of ABI stub functions

{}
// End of ABI stub functions
        }}
    }}
}}
)";

    static inline constexpr std::string_view c_outer_abi_function = R"(
void* CALLBACK {}_Generated_Stub(void* function_context)
{{
    try
    {{
        HRESULT __hr = ([&]() noexcept
            {{
// Start stub function body

{}

// End stub function body
            }}
        )();
        LOG_IF_FAILED(__hr);
        RETURN_HR_AS_PVOID(__hr);
    }}
    catch (...)
    {{
        HRESULT __hr = wil::ResultFromCaughtException();
        LOG_IF_FAILED(__hr);
        RETURN_HR_AS_PVOID(__hr);
    }}
}}

)";

    // This body is specific to the developer function
    static inline constexpr std::string_view c_inner_abi_function_with_result = R"(
// Create parameter tuple type
using FunctionParams = {};

// Pass void* function context, parameters, developer impl function
// and a parameter verifier function to the CallEnclaveFunction abi function
THROW_IF_FAILED((CallEnclaveFunctionWithResult<{}, FunctionParams>(
    function_context,
    VTL1_Implementations::AbiDefinitions::{}_Abi_Impl,
    ParameterVerifiers::CopyAndVerifyFor_{}<FunctionParams>)));

return S_OK;
)";

    // This body is specific to the developer function
    static inline constexpr std::string_view c_inner_abi_function_no_result = R"(
// Create parameter tuple type
using FunctionParams = {};

// Pass void* function context, parameters, developer impl function
// and a parameter verifier function to the CallEnclaveFunction abi function
THROW_IF_FAILED((CallEnclaveFunctionNoResult<FunctionParams>(
    function_context,
    VTL1_Implementations::AbiDefinitions::{}_Abi_Impl,
    ParameterVerifiers::CopyAndVerifyFor_{}<FunctionParams>)));

return S_OK;
)";

    static inline constexpr std::string_view c_generated_developer_impl_function = R"(
// Implementation declaration for Developer function. The Developer must implement this 
// function
{} {}{};
)";

    static inline constexpr std::string_view c_generated_abi_impl_function = R"(
// Abi impl function that forwards parameters to developers impl function declaration.
static inline {} {}_Abi_Impl{}
{{
    {}
}}
)";

    // Using a R("...") that contains a " character with std::format ends up adding a \" to the string.
    // instead of the double quote itself. So, as a work around we'll use the old style of declaring a multi line string.
    static inline constexpr std::string_view c_vtl1_enclave_func_impl_start_of_file =
"\n\
#pragma once\n\
#include <VbsEnclaveABI\\Enclave\\EnclaveHelpers.h>\n\
#include \"..\\Shared\\EnclaveDeveloperTypes.h\"\n\
\n\
using namespace VbsEnclaveABI;\n\
using namespace EnclaveDeveloperTypes;\n\
\n\
";

    static inline constexpr std::string_view c_vtl1_enclave_func_impl_namespace = R"(
namespace VbsEnclaveGenerated_{}
{{
    namespace Enclave
    {{
        namespace VTL1_Implementations
        {{
            namespace DeveloperDeclarations
            {{
// Start of developer implementation function declarations

{}
// End of developer implementation functions declarations
            }}

            namespace AbiDefinitions
            {{
// Start of ABI implementation function declarations

{}
// End of ABI implementation functions declarations
            }}
        }}
    }}
}}
)";
    // Using a R("...") that contains a " character with std::format ends up adding a \" to the string.
    // instead of the double quote itself. So, as a work around we'll use the old style of declaring a multi line string.
    static inline constexpr std::string_view c_vtl1_enclave_verifier_start_of_file =
"\n\
#pragma once\n\
#include <VbsEnclaveABI\\Enclave\\EnclaveHelpers.h>\n\
#include \"..\\Shared\\EnclaveDeveloperTypes.h\"\n\
\n\
using namespace VbsEnclaveABI;\n\
using namespace EnclaveDeveloperTypes;\n\
\n\
";

    static inline constexpr std::string_view c_vtl1_enclave_parameter_verifier_namespace = R"(
namespace VbsEnclaveGenerated_{}
{{
    namespace Enclave
    {{
        namespace ParameterVerifiers
        {{
// Start of function parameter verifiers

{}
// End of function parameter verifiers
        }}
    }}
}}
)";

    // Today this doesn't verify and just returns the same parameters
    // but in the future when Flatbuffer support is added this will be
    // changed to support that. So this is just a place holder for now
    static inline constexpr std::string_view c_generated_function_parameter_verifier = R"(
template <typename FunctionParams>
FunctionParams CopyAndVerifyFor_{} (FunctionParams parameters)
{{
    // Function verifys the parameters, copies them to
    // the vtl layer and returns the copy back to the caller
    return parameters;
}}
)";

    // Using a R("...") that contains a " character with std::format ends up adding a \" to the string.
    // instead of the double quote itself. So, as a work around we'll use the old style of declaring a multi line string.
    static inline constexpr std::string_view c_developer_types_start_of_file = 
"\n\
{}\n\
#pragma once\n\
#include <VbsEnclaveABI\\Shared\\VbsEnclaveAbiBase.h>\n\
\n\
";

    static inline constexpr std::string_view c_developer_types_namespace = R"(
namespace EnclaveDeveloperTypes
{{
// Start of developer types

{}
// End of developer types
}}
)";

    static inline constexpr std::string_view c_enclave_def_file_content = R"(
{}
LIBRARY

    EXPORTS
{}
)";
}
