// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

#pragma once 
#include <pch.h>
#include <Edl\Structures.h>
#include <Edl\Utils.h>
#include <CodeGeneration\Contants.h>
#include <CodeGeneration\CodeGeneration.h>
#include <CodeGeneration\CodeGenerationHelpers.h>
#include <CodeGeneration\Flatbuffers\Contants.h>
#include <CodeGeneration\Flatbuffers\BuilderHelpers.h>

#include <sstream>

using namespace EdlProcessor;

namespace CodeGeneration::Flatbuffers
{
    std::unordered_map<std::string, std::string> s_enum_data {};

    std::ostringstream BuildInitialFlatbufferSchemaContent(
        const std::vector<DeveloperType>& developer_types_insertion_list)
    {
        std::ostringstream schema {};
        schema << c_autogen_header_string << c_flatbuffer_namespace;

        for (auto& type : developer_types_insertion_list)
        {
            DeveloperType dev_type = type;
            if (dev_type.IsEdlType(EdlTypeKind::Enum))
            {
                schema << BuildEnum(dev_type);
            }
            else if (dev_type.IsEdlType(EdlTypeKind::Struct))
            {
                schema << BuildTable(dev_type.m_fields, dev_type.m_name);
            }
        }

        // Add Wstring table by default
        schema << c_flatbuffer_wstring_table;

        return schema;
    }

    std::string BuildEnum(const DeveloperType& enum_type)
    {
        std::ostringstream enum_body {};

        for (auto& [enum_value_name, enum_value] : enum_type.m_items)
        {
            if (enum_value.m_value)
            {
                // Raw value will only ever be an numeric value.
                Token value_token = enum_value.m_value.value();
                enum_body << std::format("    {} = {},\n", enum_value_name, value_token.ToString());
            }
            else
            {
                enum_body << std::format("    {} = {},\n", enum_value_name, enum_value.m_declared_position);
            }

            if (enum_value.m_is_default_value)
            {
                s_enum_data.emplace(enum_type.m_name, enum_value_name);
            }
        }

        return std::format(c_enum_definition, enum_type.m_name, enum_body.str());
    }

    // See flatbuffer schema for supported types https://flatbuffers.dev/schema/
    // Additional types like WString are generated by us and we have conversion
    // functions to facilitate copying between our types and flatbuffer types.
    inline std::string GetFlatBufferType(const EdlTypeInfo& type_info)
    {
        auto type_kind = type_info.m_type_kind;

        switch (type_kind)
        {
            case EdlTypeKind::Bool:
                return "bool";
            case EdlTypeKind::Char:
            case EdlTypeKind::Int8:
                return "byte";
            case EdlTypeKind::Int16:
                return "int16";
            case EdlTypeKind::HRESULT:
            case EdlTypeKind::Int32:
                return "int32";
            case EdlTypeKind::Int64:
                return "int64";
            case EdlTypeKind::Float:
                return "float32";
            case EdlTypeKind::Double:
                return "float64";
            case EdlTypeKind::UInt8:
            case EdlTypeKind::Void:
                return "uint8";
            case EdlTypeKind::WChar:
            case EdlTypeKind::UInt16:
                return "uint16";
            case EdlTypeKind::UInt32:
                return "uint32";
            case EdlTypeKind::SizeT:
            case EdlTypeKind::UInt64:
                return "uint64";
            case EdlTypeKind::String:
                return "string"; // natively supported by flatbuffers
            case EdlTypeKind::WString:
                return "WString"; // array of uint16s that we convert to std::wstring
            case EdlTypeKind::Enum:
            case EdlTypeKind::Struct:
                return type_info.m_name;
                return type_info.m_name;
            default:
                throw CodeGenerationException(
                    ErrorId::FlatbufferTypeNotCompatibleWithEdlType,
                    c_edlTypes_to_string_map.at(type_kind));
        }
    }

    std::string BuildTable(const std::vector<Declaration>& values, std::string_view struct_name)
    {
        std::ostringstream table_body {};
        std::ostringstream all_associated_tables {};

        for (const Declaration& declaration : values)
        {
            if (!declaration.m_array_dimensions.empty())
            {
                // Note: pointer data will be placed into a flatbuffer vector and reconstructed
                // on the other side.
                table_body << std::format(
                    "    {} : [{}];\n",
                    declaration.m_name,
                    GetFlatBufferType(declaration.m_edl_type_info));
            }
            else if (declaration.IsEdlType(EdlTypeKind::Struct))
            {
                table_body << std::format(
                    "    {} : {};\n",
                    declaration.m_name,
                    declaration.m_edl_type_info.m_name);
            }
            else if (declaration.IsEdlType(EdlTypeKind::Enum))
            {
                table_body << std::format(
                    "    {} : {} = {};\n",
                    declaration.m_name,
                    declaration.m_edl_type_info.m_name,
                    s_enum_data.at(declaration.m_edl_type_info.m_name));
            }
            else
            {
                table_body << std::format(
                    "    {} : {};\n",
                    declaration.m_name,
                    GetFlatBufferType(declaration.m_edl_type_info));
            }
        }

        all_associated_tables << std::format(c_table_definition, struct_name, table_body.str());

        return all_associated_tables.str();
    }

    FlatbufferSupportedTypes GetSupportedFlatbufferTypeKind(const Declaration& declaration)
    {
        auto& type_info = declaration.m_edl_type_info;

        // These are the types we support. Just like the WString case we can always
        // create a custom type using the natively supported types of flatbuffers
        // should we ever need to expand this.
        switch (type_info.m_type_kind)
        {
            case EdlTypeKind::Bool:
            case EdlTypeKind::Char:
            case EdlTypeKind::Int8:
            case EdlTypeKind::WChar:
            case EdlTypeKind::Int16:
            case EdlTypeKind::HRESULT:
            case EdlTypeKind::Int32:
            case EdlTypeKind::Int64:
            case EdlTypeKind::Float:
            case EdlTypeKind::Double:
            case EdlTypeKind::UInt8:
            case EdlTypeKind::UInt16:
            case EdlTypeKind::UInt32:
            case EdlTypeKind::SizeT:
            case EdlTypeKind::UInt64:
            case EdlTypeKind::String:
                return FlatbufferSupportedTypes::Basic;
            case EdlTypeKind::WString:
                return FlatbufferSupportedTypes::WString;
            case EdlTypeKind::Enum:
                return FlatbufferSupportedTypes::Enum;
            case EdlTypeKind::Struct:
                return FlatbufferSupportedTypes::NestedStruct;
            default:
                throw CodeGenerationException(
                    ErrorId::FlatbufferTypeNotCompatibleWithEdlType,
                    type_info.m_name,
                    declaration.m_name);
        }
    }

    FlatbufferDataForFunction BuildFlatbufferConversionStructsAndTables(
       Function function,
       std::string_view abi_function_name,
       const CppCodeBuilder::FunctionParametersInfo& params_info)
    {
        std::vector<Declaration> all_params {};

        // Add return type to out struct if it's not void.
        if (function.m_return_info.IsEdlType(EdlTypeKind::Void))
        {
            function.m_parameters.push_back(function.m_return_info);
        }

        auto params_size = function.m_parameters.size();

        for (size_t param_index = 0U; param_index < params_size; param_index++)
        {
            Declaration& parameter = function.m_parameters[param_index];
            parameter.m_name = "m_" + parameter.m_name;
            all_params.push_back(parameter);
        }

        FlatbufferDataForFunction data {};

        // Struct that will be used to pass and return the function params/return type.
        auto struct_name = std::format(c_function_args_struct, abi_function_name);
        data.m_flatbuffer_tables << BuildTable(function.m_parameters, struct_name);
        data.m_parameters_struct << CppCodeBuilder::BuildStructDefinitionForFunctionParams(
            struct_name,
            all_params,
            params_info);

        return data;
    }
}
