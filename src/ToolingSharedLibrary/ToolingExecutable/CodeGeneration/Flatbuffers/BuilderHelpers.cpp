// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

#include <pch.h>
#include <Edl\Structures.h>
#include <Edl\Utils.h>
#include <CodeGeneration\Constants.h>
#include <CodeGeneration\CodeGeneration.h>
#include <CodeGeneration\CodeGenerationHelpers.h>
#include <CodeGeneration\Flatbuffers\Constants.h>
#include <CodeGeneration\Flatbuffers\BuilderHelpers.h>

#include <sstream>

using namespace EdlProcessor;

namespace CodeGeneration::Flatbuffers
{
    std::unordered_map<std::string, std::string> g_enum_data {};

    std::string GenerateFlatbufferSchema(
        std::string_view developer_namespace_name,
        const OrderedMap<std::string, DeveloperType>& developer_types,
        const std::vector<DeveloperType>& abi_function_developer_types)
    {
        std::ostringstream schema {};
        auto schema_namespace = std::format(c_flatbuffer_namespace, developer_namespace_name);
        schema << c_autogen_header_string << schema_namespace;

        for (const auto& dev_type : developer_types.values())
        {
            if (dev_type.IsEdlType(EdlTypeKind::Enum))
            {
                schema << BuildEnum(dev_type);
            }
            else if (dev_type.IsEdlType(EdlTypeKind::Struct))
            {
                schema << BuildTable(dev_type.m_fields, dev_type.m_name);
            }
        }

        for (auto& dev_type : abi_function_developer_types)
        {
            // type will only ever be structs
            schema << BuildTable(dev_type.m_fields, dev_type.m_name);
        }

        // Add Wstring table by default
        schema << c_flatbuffer_wstring_table;

        schema << c_flatbuffer_register_callback_tables;

        schema << c_flatbuffer_root_table << c_flatbuffer_root_type;

        return schema.str();
    }

    std::string BuildEnum(const DeveloperType& enum_type)
    {
        std::ostringstream enum_body {};

        for (auto& enum_value : enum_type.m_items.values())
        {
            if (enum_value.m_value)
            {
                // Raw value will only ever be an numeric value.
                enum_body << std::format("    {} = {},\n", enum_value.m_name, enum_value.m_value.value());
            }
            else
            {
                enum_body << std::format("    {} = {},\n", enum_value.m_name, enum_value.m_declared_position);
            }

            if (enum_value.m_is_default_value)
            {
                g_enum_data.emplace(enum_type.m_name, enum_value.m_name);
            }
        }

        return std::format(c_enum_definition, enum_type.m_name, enum_body.str());
    }

    // See flatbuffer schema for supported types https://flatbuffers.dev/schema/
    // Additional types like WString are generated by us and we have conversion
    // functions to facilitate copying between our types and flatbuffer types.
    inline std::string GetFlatBufferType(const EdlTypeInfo& type_info)
    {
        auto type_kind = type_info.m_type_kind;

        switch (type_kind)
        {
            case EdlTypeKind::Bool:
                return "bool";
            case EdlTypeKind::Char:
            case EdlTypeKind::Int8:
                return "byte";
            case EdlTypeKind::Int16:
                return "int16";
            case EdlTypeKind::HRESULT:
            case EdlTypeKind::Int32:
                return "int32";
            case EdlTypeKind::Int64:
                return "int64";
            case EdlTypeKind::Float:
                return "float32";
            case EdlTypeKind::Double:
                return "float64";
            case EdlTypeKind::UInt8:
            case EdlTypeKind::Void:
                return "uint8";
            case EdlTypeKind::WChar:
            case EdlTypeKind::UInt16:
                return "uint16";
            case EdlTypeKind::UInt32:
                return "uint32";
            case EdlTypeKind::SizeT:
            case EdlTypeKind::UInt64:
            case EdlTypeKind::UIntPtr:
                return "uint64";
            case EdlTypeKind::String:
                return "string"; // natively supported by flatbuffers
            case EdlTypeKind::WString:
                return "WString"; // array of uint16s that we convert to std::wstring
            case EdlTypeKind::Enum:
            case EdlTypeKind::Struct:
                return type_info.m_name;
            default:
                throw CodeGenerationException(
                    ErrorId::FlatbufferTypeNotCompatibleWithEdlType,
                    c_edlTypes_to_string_map.at(type_kind));
        }
    }

    std::string GetNativeInlineStringForVector(const EdlTypeInfo& info)
    {
        // By default for vectors of tables/structs the Flatbuffer object-api will generate the
        // vector as a vector<unique_ptr<T>>. However when '(native_inline)' is used the api will generate the 
        // vector as a vector<T>. We want this behavior so we can limit the amount of memory the abi allocates. 
        // Flatbuffer generates all other types within vectors as vector<T> by default. WString is special 
        // because we generate it as a Flatbuffer table that contains a vector of uint16's.
        // Note for Rust: The required keyword is needed for the native_inline to work properly.
        std::string inline_type_string = "";
        if (info.m_type_kind == EdlTypeKind::Struct ||
            info.m_type_kind == EdlTypeKind::WString)
        {
            inline_type_string = "(native_inline, required)";
        }

        return inline_type_string;
    }

    std::string GetRequiredStringForField(const Declaration& declaration)
    {
        // Fields that represent Out-parameters or pointers must be declared as optional in
        // the FlatBuffer schema; in all other cases, they should be marked as required.
        return (declaration.IsOutParameterOnly() || declaration.HasPointer()) ? "" : "(required)";
    }

    std::string BuildTable(const std::vector<Declaration>& values, std::string_view struct_name)
    {
        std::ostringstream table_body {};
        std::ostringstream all_associated_tables {};

        for (const Declaration& declaration : values)
        {
            if (!declaration.m_array_dimensions.empty())
            {
                table_body << std::format(
                    "    {} : [{}] {};\n",
                    declaration.m_name,
                    GetFlatBufferType(declaration.m_edl_type_info),
                    GetNativeInlineStringForVector(declaration.m_edl_type_info));
            }
            else if (declaration.IsEdlType(EdlTypeKind::Vector))
            {
                auto& inner_type = declaration.m_edl_type_info.inner_type;

                table_body << std::format(
                    "    {} : [{}] {};\n",
                    declaration.m_name,
                    GetFlatBufferType(*inner_type),
                    GetNativeInlineStringForVector(*inner_type));
            }
            else if (declaration.IsEdlType(EdlTypeKind::Optional))
            {
                auto& inner_type = declaration.m_edl_type_info.inner_type;
                bool is_inner_a_struct = inner_type->m_type_kind == EdlTypeKind::Struct;

                // In the flatbuffer schema, structs are optional by default without the "= null" expression.
                // All other types need the "= null" expression to be considered optional.
                auto optional_val = is_inner_a_struct ? "" : "= null";
                table_body << std::format(
                    "    {} : {} {};\n",
                    declaration.m_name,
                    GetFlatBufferType(*inner_type),
                    optional_val);
            }
            else if (declaration.IsEdlType(EdlTypeKind::Struct))
            {
                // We generate structs as tables using the Flatbuffer object api. Unfortunately for C++ it generates nested
                // tables as unique_ptr<T> where T is the Flatbuffer representation of the struct. There is currently
                // no way to generate nested tables as type T instead of unique_ptr<T> like in the case of vectors.
                // See: https://github.com/google/flatbuffers/issues/4969

                table_body << std::format(
                    "    {} : {} {};\n",
                    declaration.m_name,
                    declaration.m_edl_type_info.m_name,
                    GetRequiredStringForField(declaration));
            }
            else if (declaration.IsEdlType(EdlTypeKind::Enum))
            {
                // pointers to enums will have their flatbuffer counterpart be generated as an optional value
                // when given the null value. In C++ for example that is an std::optional.
                auto default_val = declaration.HasPointer() ? "null" : g_enum_data.at(declaration.m_edl_type_info.m_name);
                table_body << std::format(
                    "    {} : {} = {};\n",
                    declaration.m_name,
                    declaration.m_edl_type_info.m_name,
                    default_val);
            }
            else
            {
                // pointers to primitives will have their flatbuffer counterpart be generated as an optional value
                // when given the null value. In C++ for example that is an std::optional.
                auto null_val = declaration.HasPointer() ? " = null" : "";
                table_body << std::format(
                    "    {} : {}{};\n",
                    declaration.m_name,
                    GetFlatBufferType(declaration.m_edl_type_info),
                    null_val);
            }
        }

        all_associated_tables << std::format(c_table_definition, struct_name, table_body.str());

        return all_associated_tables.str();
    }
}
