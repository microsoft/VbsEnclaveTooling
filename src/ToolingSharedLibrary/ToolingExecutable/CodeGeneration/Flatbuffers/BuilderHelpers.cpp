// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

#pragma once 
#include <pch.h>
#include <Edl\Structures.h>
#include <Edl\Utils.h>
#include <CodeGeneration\Contants.h>
#include <CodeGeneration\CodeGeneration.h>
#include <CodeGeneration\CodeGenerationHelpers.h>
#include <CodeGeneration\Flatbuffers\Contants.h>
#include <CodeGeneration\Flatbuffers\BuilderHelpers.h>

#include <sstream>

using namespace EdlProcessor;

namespace CodeGeneration::Flatbuffers
{
    std::unordered_map<std::string, std::string> s_enum_data {};

    std::ostringstream BuildInitialFlatbufferSchemaContent(
        const std::vector<DeveloperType>& developer_types_insertion_list)
    {
        std::ostringstream schema {};
        schema << c_autogen_header_string << c_flatbuffer_namespace;

        for (auto& type : developer_types_insertion_list)
        {
            if (type.IsEdlType(EdlTypeKind::Enum))
            {
                schema << BuildEnum(type);
            }
            else if (type.IsEdlType(EdlTypeKind::Struct))
            {
                schema << BuildTable(type.m_fields, type.m_name);
            }
        }

        // Add Wstring table by default
        schema << c_flatbuffer_wstring_table;

        return schema;
    }

    std::string BuildEnum(const DeveloperType& enum_type)
    {
        std::ostringstream enum_body {};

        for (auto& [enum_value_name, enum_value] : enum_type.m_items)
        {
            if (enum_value.m_value)
            {
                // Raw value will only ever be an numeric value.
                Token value_token = enum_value.m_value.value();
                enum_body << std::format("    {} = {},\n", enum_value_name, value_token.ToString());
            }
            else
            {
                enum_body << std::format("    {} = {},\n", enum_value_name, enum_value.m_declared_position);
            }

            if (enum_value.m_is_default_value)
            {
                s_enum_data.emplace(enum_type.m_name, enum_value_name);
            }
        }

        return std::format(c_enum_definition, enum_type.m_name, enum_body.str());
    }

    // See flatbuffer schema for supported types https://flatbuffers.dev/schema/
    // Additional types like WString are generated by us and we have conversion
    // functions to facilitate copying between our types and flatbuffer types.
    inline std::string GetFlatBufferType(const EdlTypeInfo& type_info)
    {
        auto type_kind = type_info.m_type_kind;

        switch (type_kind)
        {
            case EdlTypeKind::Bool:
                return "bool";
            case EdlTypeKind::Char:
            case EdlTypeKind::Int8:
                return "byte";
            case EdlTypeKind::Int16:
                return "int16";
            case EdlTypeKind::HRESULT:
            case EdlTypeKind::Int32:
                return "int32";
            case EdlTypeKind::Int64:
                return "int64";
            case EdlTypeKind::Float:
                return "float32";
            case EdlTypeKind::Double:
                return "float64";
            case EdlTypeKind::UInt8:
            case EdlTypeKind::Void:
                return "uint8";
            case EdlTypeKind::WChar:
            case EdlTypeKind::UInt16:
                return "uint16";
            case EdlTypeKind::UInt32:
                return "uint32";
            case EdlTypeKind::SizeT:
            case EdlTypeKind::UInt64:
            case EdlTypeKind::UIntPtr:
                return "uint64";
            case EdlTypeKind::String:
                return "string"; // natively supported by flatbuffers
            case EdlTypeKind::WString:
                return "WString"; // array of uint16s that we convert to std::wstring
            case EdlTypeKind::Enum:
            case EdlTypeKind::Struct:
                return type_info.m_name;
            default:
                throw CodeGenerationException(
                    ErrorId::FlatbufferTypeNotCompatibleWithEdlType,
                    c_edlTypes_to_string_map.at(type_kind));
        }
    }

    std::string BuildTable(const std::vector<Declaration>& values, std::string_view struct_name)
    {
        std::ostringstream table_body {};
        std::ostringstream all_associated_tables {};

        for (const Declaration& declaration : values)
        {
            if (!declaration.m_array_dimensions.empty())
            {
                table_body << std::format(
                    "    {} : [{}];\n",
                    declaration.m_name,
                    GetFlatBufferType(declaration.m_edl_type_info));
            }
            else if (declaration.IsEdlType(EdlTypeKind::Vector))
            {
                auto& inner_type = declaration.m_edl_type_info.inner_type;
                table_body << std::format(
                    "    {} : [{}];\n",
                    declaration.m_name,
                    GetFlatBufferType(*inner_type));
            }
            else if (declaration.IsEdlType(EdlTypeKind::Struct))
            {
                table_body << std::format(
                    "    {} : {};\n",
                    declaration.m_name,
                    declaration.m_edl_type_info.m_name);
            }
            else if (declaration.IsEdlType(EdlTypeKind::Enum))
            {
                table_body << std::format(
                    "    {} : {} = {};\n",
                    declaration.m_name,
                    declaration.m_edl_type_info.m_name,
                    s_enum_data.at(declaration.m_edl_type_info.m_name));
            }
            else
            {
                table_body << std::format(
                    "    {} : {};\n",
                    declaration.m_name,
                    GetFlatBufferType(declaration.m_edl_type_info));
            }
        }

        all_associated_tables << std::format(c_table_definition, struct_name, table_body.str());

        return all_associated_tables.str();
    }

    FlatbufferSupportedTypes GetSupportedFlatbufferTypeKindForVector(const Declaration& declaration)
    {
        auto inner_type = declaration.m_edl_type_info.inner_type;

        if (inner_type && inner_type->m_type_kind == EdlTypeKind::Enum)
        {
            return FlatbufferSupportedTypes::LinearVectorEnums;
        }
        else if (inner_type && inner_type->m_type_kind == EdlTypeKind::Struct)
        {
            return FlatbufferSupportedTypes::LinearVectorStructs;
        }
        else if (inner_type && inner_type->m_type_kind == EdlTypeKind::WString)
        {
            return FlatbufferSupportedTypes::LinearVectorWString;
        }

        return FlatbufferSupportedTypes::LinearVectorBasic;
    }

    FlatbufferSupportedTypes GetSupportedFlatbufferTypeKind(const Declaration& declaration)
    {
        auto& type_info = declaration.m_edl_type_info;

        // These are the types we support. Just like the WString case we can always
        // create a custom type using the natively supported types of flatbuffers
        // should we ever need to expand this.
        switch (type_info.m_type_kind)
        {
            case EdlTypeKind::Bool:
            case EdlTypeKind::Char:
            case EdlTypeKind::Int8:
            case EdlTypeKind::WChar:
            case EdlTypeKind::Int16:
            case EdlTypeKind::HRESULT:
            case EdlTypeKind::Int32:
            case EdlTypeKind::Int64:
            case EdlTypeKind::Float:
            case EdlTypeKind::Double:
            case EdlTypeKind::UInt8:
            case EdlTypeKind::UInt16:
            case EdlTypeKind::UInt32:
            case EdlTypeKind::SizeT:
            case EdlTypeKind::UInt64:
            case EdlTypeKind::UIntPtr:
            case EdlTypeKind::String:
                return FlatbufferSupportedTypes::Basic;
            case EdlTypeKind::WString:
                return FlatbufferSupportedTypes::WString;
            case EdlTypeKind::Enum:
                return FlatbufferSupportedTypes::Enum;
            case EdlTypeKind::Struct:
                return FlatbufferSupportedTypes::NestedStruct;
            case EdlTypeKind::Vector:
                return GetSupportedFlatbufferTypeKindForVector(declaration);
            default:
                throw CodeGenerationException(
                    ErrorId::FlatbufferTypeNotCompatibleWithEdlType,
                    type_info.m_name,
                    declaration.m_name);
        }
    }

    std::string BuildConversionFunctionBody(
        const std::vector<Declaration>& fields,
        FlatbufferConversionKind conversion_kind,
        FlatbufferStructFieldsModifier modifier)
    {
        std::ostringstream copy_statements {};

        for (auto& declaration : fields)
        {
            FlatbufferSupportedTypes flatbuffer_type {};

            if (!declaration.m_array_dimensions.empty())
            {
                if (declaration.IsEdlType(EdlTypeKind::Struct))
                {
                    flatbuffer_type = FlatbufferSupportedTypes::LinearArrayStructs;
                }
                else if (declaration.IsEdlType(EdlTypeKind::WString))
                {
                    flatbuffer_type = FlatbufferSupportedTypes::LinearArrayWString;
                }
                else if (declaration.IsEdlType(EdlTypeKind::Enum))
                {
                    flatbuffer_type = FlatbufferSupportedTypes::LinearArrayEnums;
                }
                else
                {
                    flatbuffer_type = FlatbufferSupportedTypes::LinearArrayBasic;
                }
            }
            else if (declaration.HasPointer())
            {
                if (declaration.IsEdlType(EdlTypeKind::Enum))
                {
                    flatbuffer_type = FlatbufferSupportedTypes::PtrForEnum;
                }
                else  if (declaration.IsEdlType(EdlTypeKind::Struct))
                {
                    flatbuffer_type = FlatbufferSupportedTypes::PtrForStruct;
                }
                else
                {
                    flatbuffer_type = FlatbufferSupportedTypes::PtrForPrimitive;
                }
            }
            else
            {
                flatbuffer_type = GetSupportedFlatbufferTypeKind(declaration);
            }

            std::string flatbuffer_side = std::format("flatbuffer.{}", declaration.m_name);
            std::string struct_side = std::format("dev_type.{}", declaration.m_name);
            FieldNameDataForCopyStatements variable_names {flatbuffer_side, struct_side, modifier};

            if (conversion_kind == FlatbufferConversionKind::ToFlatbuffer &&
                modifier == FlatbufferStructFieldsModifier::AbiToFlatbufferMultipleParameters)
            {
                variable_names = {flatbuffer_side, declaration.m_name, modifier};
                copy_statements << GetDevTypeToFlatbufferCopyStatements(declaration, flatbuffer_type, variable_names);
            }
            else if (conversion_kind == FlatbufferConversionKind::ToFlatbuffer)
            {
                copy_statements << GetDevTypeToFlatbufferCopyStatements(declaration, flatbuffer_type, variable_names);
            }

            if (conversion_kind == FlatbufferConversionKind::ToDevType)
            {
                copy_statements << GetFlatbufferToDevTypeCopyStatements(declaration, flatbuffer_type, variable_names);
            }
        }

        return copy_statements.str();
    }

    std::string FormatStringForDevTypeToFlatbufferPtr(
        std::string_view last_part,
        const FieldNameDataForCopyStatements& field_names)
    {
        return FormatString(
             c_dev_type_to_flatbuffer_conversion_ptr_base_smartptr,
             field_names.m_struct,
             last_part);
    }

    std::string GetDevTypeToFlatbufferCopyStatements(
        const Declaration& declaration,
        FlatbufferSupportedTypes type_kind,
        FieldNameDataForCopyStatements field_names)
    {
        std::string_view string_to_format = c_dev_type_to_flatbuffer_statement_map.at(type_kind);
        std::string_view field_name = declaration.m_name;
        std::string_view obj_type = declaration.m_edl_type_info.m_name;
        std::string buf_size = GetSizeFromAttribute(declaration);
        std::string_view flatbuffer_field = field_names.m_flatbuffer;
        std::string_view struct_field = field_names.m_struct;

        if (type_kind == FlatbufferSupportedTypes::LinearArrayBasic)
        {
            return FormatString(string_to_format, flatbuffer_field, struct_field, struct_field);
        }
        else if (type_kind == FlatbufferSupportedTypes::LinearArrayStructs)
        {
            return FormatString(
                string_to_format,
                flatbuffer_field,
                struct_field,
                struct_field,
                struct_field,
                flatbuffer_field,
                obj_type);
        }
        else if (type_kind == FlatbufferSupportedTypes::LinearArrayEnums)
        {
            return FormatString(string_to_format,
                flatbuffer_field,
                struct_field,
                struct_field,
                struct_field,
                flatbuffer_field,
                obj_type,
                obj_type);
        }
        else if (type_kind == FlatbufferSupportedTypes::LinearArrayWString)
        {
            return FormatString(string_to_format, flatbuffer_field, struct_field, struct_field, struct_field, flatbuffer_field);
        }
        else if (type_kind == FlatbufferSupportedTypes::LinearVectorBasic)
        {
            return FormatString(string_to_format, flatbuffer_field, struct_field, struct_field);
        }
        else if (type_kind == FlatbufferSupportedTypes::LinearVectorEnums)
        {
            return FormatString(
               string_to_format,
               flatbuffer_field,
               struct_field,
               struct_field,
               struct_field,
               flatbuffer_field,
               declaration.m_edl_type_info.inner_type->m_name,
               declaration.m_edl_type_info.inner_type->m_name);
        }
        else if (type_kind == FlatbufferSupportedTypes::LinearVectorStructs)
        {
            auto inner_type_name = declaration.m_edl_type_info.inner_type->m_name;
            return FormatString(
                string_to_format,
                flatbuffer_field,
                struct_field,
                struct_field,
                struct_field,
                flatbuffer_field,
                inner_type_name);
        }
        else if (type_kind == FlatbufferSupportedTypes::LinearVectorWString)
        {
            return FormatString(string_to_format, flatbuffer_field, struct_field, struct_field, struct_field, flatbuffer_field);
        }
        else if (type_kind == FlatbufferSupportedTypes::PtrForPrimitive)
        {
            auto statement = FormatString(string_to_format, flatbuffer_field, struct_field);
            return FormatStringForDevTypeToFlatbufferPtr(statement, field_names);
        }
        else if (type_kind == FlatbufferSupportedTypes::PtrForEnum)
        {
            auto statement = FormatString(string_to_format, flatbuffer_field, obj_type, struct_field);
            return FormatStringForDevTypeToFlatbufferPtr(statement, field_names);
        }
        else if (type_kind == FlatbufferSupportedTypes::PtrForStruct)
        {
            auto statement = FormatString(string_to_format, flatbuffer_field, obj_type, struct_field);
            return FormatStringForDevTypeToFlatbufferPtr(statement, field_names);
        }
        else if (type_kind == FlatbufferSupportedTypes::Basic || type_kind == FlatbufferSupportedTypes::WString)
        {
            return FormatString(string_to_format, flatbuffer_field, struct_field);
        }
        else
        {
            // FlatbufferSupportedTypes::NestedStruct and FlatbufferSupportedTypes::Enum
            return FormatString(string_to_format, flatbuffer_field, obj_type, struct_field);
        }
    }

    std::string GetFlatbufferToDevTypeCopyStatements(
        const Declaration& declaration,
        FlatbufferSupportedTypes type_kind,
        FieldNameDataForCopyStatements field_names)
    {
        std::string_view string_to_format = c_flatbuffer_to_dev_type_statement_map.at(type_kind);
        std::string_view obj_type = declaration.m_edl_type_info.m_name;
        std::string_view flatbuffer_field = field_names.m_flatbuffer;
        std::string_view struct_field = field_names.m_struct;

        if (type_kind == FlatbufferSupportedTypes::LinearArrayBasic)
        {
            std::string arr_size = declaration.m_array_dimensions[0];
            return FormatString(
                string_to_format,
                flatbuffer_field,
                flatbuffer_field,
                arr_size,
                flatbuffer_field,
                flatbuffer_field,
                struct_field);
        }
        else if (type_kind == FlatbufferSupportedTypes::LinearArrayStructs)
        {
            auto to_dev_type_func_name = GetToDevTypeFunctionName(declaration);
            std::string arr_size = declaration.m_array_dimensions[0];
            return FormatString(
                string_to_format,
                flatbuffer_field,
                flatbuffer_field,
                arr_size,
                flatbuffer_field,
                flatbuffer_field,
                struct_field,
                obj_type,
                to_dev_type_func_name,
                flatbuffer_field);
        }
        else if (type_kind == FlatbufferSupportedTypes::LinearArrayEnums)
        {
            std::string arr_size = declaration.m_array_dimensions[0];
            return FormatString(
                string_to_format,
                flatbuffer_field,
                flatbuffer_field,
                arr_size,
                flatbuffer_field,
                flatbuffer_field,
                struct_field,
                obj_type,
                obj_type);
        }
        else if (type_kind == FlatbufferSupportedTypes::LinearArrayWString)
        {
            std::string arr_size = declaration.m_array_dimensions[0];
            return FormatString(
                string_to_format,
                flatbuffer_field,
                flatbuffer_field,
                arr_size,
                flatbuffer_field,
                flatbuffer_field,
                struct_field,
                flatbuffer_field);
        }
        else if (type_kind == FlatbufferSupportedTypes::LinearVectorBasic)
        {
            return FormatString(string_to_format, struct_field, flatbuffer_field, flatbuffer_field);
        }
        else if (type_kind == FlatbufferSupportedTypes::LinearVectorEnums)
        {
            return FormatString(
                string_to_format,
                struct_field,
                flatbuffer_field,
                flatbuffer_field,
                flatbuffer_field,
                struct_field,
                declaration.m_edl_type_info.inner_type->m_name,
                declaration.m_edl_type_info.inner_type->m_name);
        }
        else if (type_kind == FlatbufferSupportedTypes::LinearVectorStructs)
        {
            auto to_dev_type_func_name = GetToDevTypeFunctionName(declaration);
            auto inner_type_name = declaration.m_edl_type_info.inner_type->m_name;
            return FormatString(
                string_to_format,
                struct_field,
                flatbuffer_field,
                flatbuffer_field,
                flatbuffer_field,
                struct_field,
                inner_type_name,
                to_dev_type_func_name,
                flatbuffer_field);
        }
        else if (type_kind == FlatbufferSupportedTypes::LinearVectorWString)
        {
            return FormatString(
                string_to_format,
                struct_field,
                flatbuffer_field,
                flatbuffer_field,
                flatbuffer_field,
                struct_field,
                flatbuffer_field);
        }
        else if (type_kind == FlatbufferSupportedTypes::PtrForPrimitive)
        {
            return FormatString(
                string_to_format, 
                struct_field,
                obj_type,
                struct_field,
                struct_field,
                flatbuffer_field);
        }
        else if (type_kind == FlatbufferSupportedTypes::PtrForEnum)
        {
            return FormatString(
                string_to_format,
                struct_field,
                obj_type,
                struct_field,
                struct_field,
                obj_type,
                flatbuffer_field);
        }
        else if (type_kind == FlatbufferSupportedTypes::PtrForStruct)
        {
            auto to_dev_type_func_name = GetToDevTypeFunctionName(declaration);
            return FormatString(
                string_to_format,
                flatbuffer_field,
                struct_field,
                obj_type,
                to_dev_type_func_name,
                flatbuffer_field);
        }
        else if (type_kind == FlatbufferSupportedTypes::Basic)
        {
            return FormatString(string_to_format, struct_field, flatbuffer_field);
        }
        else if (type_kind == FlatbufferSupportedTypes::WString)
        {
            return FormatString(string_to_format, flatbuffer_field, struct_field, flatbuffer_field);
        }
        else if (type_kind == FlatbufferSupportedTypes::Enum)
        {
            return FormatString(string_to_format, struct_field, obj_type, flatbuffer_field);
        }
        else if (type_kind == FlatbufferSupportedTypes::NestedStruct)
        {
            auto to_dev_type_func_name = GetToDevTypeFunctionName(declaration);
            return FormatString(string_to_format, flatbuffer_field, struct_field, obj_type, to_dev_type_func_name, flatbuffer_field);
        }
        else
        {
            // FlatbufferSupportedTypes::NestedStruct
            return FormatString(string_to_format, flatbuffer_field, struct_field, obj_type, flatbuffer_field);
        }
    }

    FlatbufferDataForFunction BuildFlatbufferConversionStructsAndTables(
       const Function& original_function,
       std::string_view abi_function_name,
       const CppCodeBuilder::FunctionParametersInfo& params_info)
    {
        std::unordered_map<std::string, Declaration> all_in_and_inout_params {};
        auto updated_function = original_function;

        // Add return type to out struct if it's not void.
        if (!updated_function.m_return_info.IsEdlType(EdlTypeKind::Void))
        {
            updated_function.m_parameters.push_back(updated_function.m_return_info);
        }

        auto params_size = updated_function.m_parameters.size();

        for (size_t param_index = 0U; param_index < params_size; param_index++)
        {
            Declaration& parameter = updated_function.m_parameters[param_index];
            parameter.m_name = "m_" + parameter.m_name;

            if (!parameter.IsOutParameterOnly())
            {
                all_in_and_inout_params.emplace(parameter.m_name, parameter);
            }

            // update parent kind after adding to the set.
            parameter.m_parent_kind =  DeclarationParentKind::Struct;
        }

        FlatbufferDataForFunction data {};

        // Struct that will be used to pass and return the function params/return type.
        auto struct_name = std::format(c_function_args_struct, abi_function_name);
        data.m_flatbuffer_tables << BuildTable(updated_function.m_parameters, struct_name);
        data.m_parameters_struct << CppCodeBuilder::BuildStructDefinitionForFunctionParams(
            struct_name,
            updated_function.m_parameters,
            all_in_and_inout_params,
            params_info);

        return data;
    }
}
