#pragma once

#include <veil.any.h>

#ifndef ENCLAVE_REPORT_DATA_LENGTH
#define ENCLAVE_REPORT_DATA_LENGTH 64
#endif


// move this?
struct EnclaveKeyContent
{
    uint32_t Version;
    uint32_t publicKeySize;
    uint32_t sealedKeySize;
};


namespace veil::any
{
    namespace implementation
    {
        namespace args
        {


            struct StartHelloSession
            {
                UINT32 challengeByteCount; // IN
                PUINT8 challenge;          // IN, VTL0, comes from NGC trustlet

                // The structure in sealedAttestationBlob is opaque to VTL0, but contains
                // an attestation report from the enclave with the nonce and a symmetric
                // key, encrypted for NGC trustlet. This symmetric key is used by the
                // enclave  and the NGC trustlet to establish a secure channel.
                UINT32 sealedAttestationBlobByteCount; // OUT
                PVOID sealedAttestationBlob;           // OUT, VTL0

                UINT64 sessionHandle; // OUT
            };

            struct ExportKey
            {
                UINT64 encryptionKeyHandle;

                UINT32 keyDataByteCount; // OUT
                PVOID keyData;           // OUT, VTL0
            };

            struct CreateAttestationReport
            {
                UINT32 enclaveReportDataByteCount; // IN
                PUINT8 enclaveReportData;          // IN, VTL0, comes from NGC trustlet

                // The structure in sealedAttestationBlob is opaque to VTL0, but contains
                // an attestation report from the enclave with the nonce and a symmetric
                // key, encrypted for NGC trustlet. This symmetric key is used by the
                // enclave  and the NGC trustlet to establish a secure channel.
                UINT32 attestationReportByteCount; // OUT
                PVOID attestationReport;           // OUT, VTL0
            };

            struct ValidatePackagedEnclaveIdentityProof
            {
                UINT32 proofByteCount; // IN
                PUINT8 proof;          // IN, VTL0, comes from NGC trustlet

                UINT32 userIdByteCount; // IN
                PUINT8 userId;          // IN, VTL0

                UINT32 status;
            };

            struct retrieve_enclave_error_for_thread
            {
                

                UINT32 status;
            };

            struct register_callbacks
            {
                veil::implementation::callback_t* callbackAddresses;
            };






            struct GenerateEncryptionKeySecuredByHello
            {
                //uint32_t keyUsage; // IN

                UINT64 sessionHandle;

                // The structure in encryptedIsSecureIdOwnerId is opaque to VTL0, but
                // contains a boolean indicating whether the owner id of the enclave
                // matches the secure id of the hello container, encrypted by NGC with
                // the symmetric key from StartCreateOrLoadRecallKey.
                UINT32 encryptedIsSecureIdOwnerIdByteCount; // IN
                PVOID encryptedIsSecureIdOwnerId;           // IN, VTL0, comes from NGC trustlet

                // The structure in encryptedCacheConfig is opaque to VTL0, but contains
                // an NCRYPT_NGC_CACHE_CONFIG structure, encrypted by NGC with the
                // symmetric key from StartCreateOrLoadRecallKey.
                UINT32 encryptedCacheConfigByteCount; // IN
                PVOID encryptedCacheConfig;           // IN, VTL0, comes from NGC trustlet

                // The structure in encryptedPublicKey is opaque to VTL0, but contains
                // the public half of a signing key for the current user, encrypted by NGC
                // with the symmetric key from StartCreateOrLoadRecallKey.
                UINT32 encryptedPublicKeyByteCount; // IN
                PVOID encryptedPublicKey;           // IN, VTL0, comes from NGC trustlet

                // The structure in ecdhPublicKey is in the clear and contains the public
                // half of an ECDH key pair generated by the enclave. This key can be used
                // by VTL0 when calling to LoadRecallKey to load an existing recall key.
                UINT32 ecdhPublicKeyByteCount; // OUT
                PVOID ecdhPublicKey;           // OUT, VTL0

                // The structure in sealedEncryptedRecallKey is opaque to VTL0, but contains
                // a symmetric key, encrypted with the Hello KEK and sealed by the enclave
                UINT32 sealedEncryptedRecallKeyByteCount; // OUT
                PVOID sealedEncryptedRecallKey;           // OUT, VTL0
            };

            struct LoadEncryptionKeySecuredByHello
            {
                UINT64 sessionHandle;

                // The structure in encryptedIsSecureIdOwnerId is opaque to VTL0, but
                // contains a boolean indicating whether the owner id of the enclave
                // matches the secure id of the hello container, encrypted by NGC with
                // the symmetric key from StartCreateOrLoadRecallKey.
                UINT32 encryptedIsSecureIdOwnerIdByteCount; // IN
                PVOID encryptedIsSecureIdOwnerId;           // IN, VTL0, comes from NGC trustlet

                // The structure in encryptedHelloKeyEncryptionKey is opaque to VTL0, but contains
                // the Hello KEK, encrypted by NGC with the symmetric key from StartCreateOrLoadRecallKey.
                UINT32 encryptedHelloKeyEncryptionKeyByteCount; // IN
                PVOID encryptedHelloKeyEncryptionKey;           // IN, VTL0, comes from NGC trustlet

                // The structure in sealedRecallKey is opaque to VTL0, but contains
                // a symmetric key, encrypted with the Hello KEK and sealed by the enclave
                UINT32 sealedRecallKeyByteCount; // IN
                PVOID sealedRecallKey;           // IN, VTL0

                UINT64 encryptionKeyHandle; // OUT
            };

            struct GetPackagedEnclaveIdentityProofChallenge
            {
                UINT32 challengeByteCount; // OUT
                PUINT8 challenge;          // OUT
            };


            struct threadpool_run_task
            {
                UINT64 threadpoolInstance; // IN
                UINT64 taskHandle; // IN
            };

            struct threadpool_make
            {
                void* enclave; // OUT
                uint64_t threadpoolInstance_vtl1;
                uint32_t threadCount;
                bool mustFinishAllQueuedTasks = true;
                void* context;          // OUT

                //// ret from cb
                void* threadpoolInstance_vtl0;
            };




        }
    }
}


