// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

// Import the generated flatbuffer_test module that was built via build.rs.
// Note: Unfortunately the flatbuffers generated files contain code that produces warnings.
// These should be fixed when these PRs in the flatbuffer repo are checked in:
// 1. https://github.com/google/flatbuffers/pull/8564
// 2. https://github.com/google/flatbuffers/pull/8709
#[allow(
    mismatched_lifetime_syntaxes,
    unsafe_op_in_unsafe_fn,
    dead_code,
    unused_imports,
    clippy::extra_unused_lifetimes,
    clippy::derivable_impls,
    clippy::missing_safety_doc
)]
pub mod fb_generated {
    include!(concat!(env!("OUT_DIR"), "/flatbuffer_gen/mod.rs"));
}

// Simulate module and items to be generated by edlcodegen.exe
// Which represent types that edl supports but flatbuffers does not.
pub mod edl_types {
    use super::fb_generated::edl_types_gen;
    use edlcodegen_core::EdlDerive;

    // Lightweight struct to hold wstring characters that are passed
    // through the codegen layer. Would be generated by edlcodgen.exe
    // Raw character bytes only.
    #[derive(Debug, Clone, PartialEq, Default, EdlDerive)]
    #[target_struct(edl_types_gen::WStringT)]
    pub struct WString {
        pub wchars: Vec<u16>,
    }
}

// Simulate module and items to be generated by edlcodegen.exe
// Which represent the types the developer used in their .edl file.
pub mod dev_types {
    use super::edl_types;
    use super::fb_generated::flatbuffer_test;
    use edlcodegen_core::EdlDerive;

    // Simulates an enum generated by edlcodgen.exe
    #[repr(C)]
    #[derive(Debug, Clone, PartialEq, Default, EdlDerive)]
    #[target_enum(flatbuffer_test::Color)]
    pub enum Color {
        #[default]
        Red,
        Green,
        Blue,
    }

    // Simulates a struct generated by edlcodgen.exe
    #[derive(Debug, Clone, PartialEq, Default, EdlDerive)]
    #[target_struct(flatbuffer_test::NestedDataT)]
    pub struct NestedData {
        pub id: u32,
        pub name: String,
        pub active: bool,
        pub values: Vec<f32>,
        pub color: Color,
    }

    // Simulates a struct generated by edlcodgen.exe
    #[derive(Debug, Clone, PartialEq, Default, EdlDerive)]
    #[target_struct(flatbuffer_test::AllTypesT)]
    pub struct AllTypes {
        pub i8_field: i8,
        pub i16_field: i16,
        pub i32_field: i32,
        pub i64_field: i64,
        pub u8_field: u8,
        pub u16_field: u16,
        pub u32_field: u32,
        pub u64_field: u64,
        pub bool_field: bool,
        pub f32_field: f32,
        pub f64_field: f64,
        pub str_field: String,
        pub color_field: Color,
        pub vec_i8: Vec<i8>,
        pub vec_i16: Vec<i16>,
        pub vec_i32: Vec<i32>,
        pub vec_i64: Vec<i64>,
        pub vec_u8: Vec<u8>,
        pub vec_u16: Vec<u16>,
        pub vec_u32: Vec<u32>,
        pub vec_u64: Vec<u64>,
        pub vec_f32: Vec<f32>,
        pub vec_f64: Vec<f64>,
        pub vec_bool: Vec<bool>,
        pub vec_str: Vec<String>,
        pub vec_color: Vec<Color>,
        pub opt_i32: Option<i32>,
        pub opt_str: Option<String>,

        #[boxed_inner_target] // flatbuffer target = Option<Box<NestedDataT>>
        pub opt_nested_struct: Option<NestedData>,

        pub opt_vec_f64: Option<Vec<f64>>,
        pub opt_vec_nested_struct: Option<Vec<NestedData>>,
        pub opt_box_to_same_struct_type: Option<Box<AllTypes>>,

        #[boxed_target] // flatbuffer target = Box<NestedDataT>
        pub nested_struct: NestedData,

        pub vec_nested_struct: Vec<NestedData>,

        #[boxed_target] // flatbuffer target = Box<edl_types_gen::WStringT>
        pub wstr: edl_types::WString,

        pub vec_wstr: Vec<edl_types::WString>,
        pub str_arr: [String; 2],
        pub nested_struct_arr: [NestedData; 2],
    }
}
