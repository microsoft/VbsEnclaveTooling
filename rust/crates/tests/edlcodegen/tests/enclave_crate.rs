// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

mod common;
mod mocks;
use common::test_helpers::*;
use common::test_types::{dev_types::AllTypes, fb_generated::flatbuffer_test::AllTypesT};

use core::ffi::c_void;
use edlcodegen_core::{
    edl_core_types::EnclaveFunctionContext,
    flatbuffer_support::{FlatbufferPack, pack_flatbuffer},
    helpers::abi_func_to_address,
};
use edlcodegen_enclave::{enclave_ffi::*, enclave_helpers::*};

#[allow(unused_imports)]
use mocks::mock_functions::*;
use windows::Win32::Foundation::S_OK;

#[cfg(test)]
mod edl_enclave {
    use edlcodegen_core::helpers::hresult_to_pvoid;
    use edlcodegen_host::{AbiError, host_helpers::call_vtl0_callback_from_vtl0};

    use crate::common::test_types::{
        dev_types::TestFuncArgs2, fb_generated::flatbuffer_test::TestFuncArgs2T,
    };

    use super::*;

    #[test]
    fn enclave_restrict_containing_process_access_happens_only_once() {
        enable_enclave_restrict_containing_process_access_once();
        enable_enclave_restrict_containing_process_access_once();
        enable_enclave_restrict_containing_process_access_once();
    }

    #[test]
    fn call_vtl1_export_from_vtl1_succeeds() {
        // Arrange
        let all_types_data = create_all_types_struct();
        let native_table: AllTypesT = all_types_data.clone().into();
        let builder = pack_flatbuffer(&native_table);
        let fb_data = builder.finished_data();
        let mut context = EnclaveFunctionContext::default();
        context.forwarded_parameters.buffer = fb_data.as_ptr() as *mut c_void;
        context.forwarded_parameters.buffer_size = fb_data.len();

        // Test function to be called by call_vtl1_export_from_vtl1.
        let dev_func = |dev_type: &mut AllTypes| -> Result<(), AbiError> {
            dev_type.i32_field = 1999; // simple mutation to verify roundtrip logic
            Ok(())
        };

        register_vtl0_callouts_helper(None, None);

        // Act
        let void_context = &mut context as *mut _ as *mut c_void;
        let result = call_vtl1_export_from_vtl1::<_, AllTypes, AllTypesT>(dev_func, void_context);

        // Assert
        assert!(
            result.is_ok(),
            "call_vtl1_export_from_vtl1 failed with Hresult: {:?}",
            result.err().unwrap().to_hresult().0
        );

        let ret_buf = context.returned_parameters.buffer as *const u8;
        let ret_size = context.returned_parameters.buffer_size;

        let ret_slice = unsafe { core::slice::from_raw_parts(ret_buf, ret_size) };
        let new_all_types_data = AllTypesT::unpack(ret_slice).unwrap();
        assert_eq!(1999, new_all_types_data.i32_field);
    }

    // A Test developer function
    // Used during the "call_vtl0_callback_from_vtl1_succeeds" test.
    fn developer_host_impl() -> String {
        String::from("This was added via generated_developer_host_impl_ffi")
    }

    // This simulates an ABI function generated by edlcodegen.exe for the host. It will call into the
    // EdlCodegen-Host crates `call_vtl0_callback_from_vtl0` function to invoke the developers impl
    // function. This is used during "call_vtl0_callback_from_vtl1_succeeds" test.
    extern "system" fn generated_developer_host_impl_ffi(context: *mut c_void) -> *mut c_void {
        // Use closure to call the developers impl function.
        let dev_func = |dev_type: &mut TestFuncArgs2| -> Result<(), AbiError> {
            // simple mutation to verify roundtrip logic
            dev_type.return_val = developer_host_impl();
            Ok(())
        };

        let result =
            call_vtl0_callback_from_vtl0::<_, TestFuncArgs2, TestFuncArgs2T>(dev_func, context);

        if let Some(err) = result.err() {
            return hresult_to_pvoid(err.to_hresult().0);
        }

        S_OK.0 as *mut c_void
    }

    #[test]
    fn call_vtl0_callback_from_vtl1_succeeds() {
        // Arrange
        let test_func_args2 = create_test_func2_args();
        let fb_native: TestFuncArgs2T = test_func_args2.into();
        let additional_addrs = vec![abi_func_to_address(generated_developer_host_impl_ffi)];
        let additional_names = vec!["generated_developer_host_impl_ffi".to_string()];
        register_vtl0_callouts_helper(Some(&additional_addrs), Some(&additional_names));

        // Act
        let result = call_vtl0_callback_from_vtl1::<TestFuncArgs2, TestFuncArgs2T>(
            &fb_native,
            "generated_developer_host_impl_ffi",
        );

        // Assert
        assert!(
            result.is_ok(),
            "call_vtl0_callback_from_vtl1 failed with {:?}",
            result.err()
        );

        let unpacked_data = result.unwrap();
        assert_eq!(
            "This was added via generated_developer_host_impl_ffi".to_string(),
            unpacked_data.return_val
        );
    }
}
