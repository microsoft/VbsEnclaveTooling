// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

// Needed for the rust file generated via flatc.exe.
// The unused imports along with unsafe warnings should be fixed once 
// https://github.com/google/flatbuffers/pull/8564 is checked in.
#![allow(unused_imports)]

// Import the generated flatbuffer_test module that was built via build.rs.
include!(concat!(env!("OUT_DIR"), "/flatbuffer_gen/mod.rs"));

// Simulate module and items to be generated by edlcodegen.exe
// Which represent types that edl supports but flatbuffers does not.
pub mod edl_types
{
    use edlcodegen_core::EdlDerive;
    use super::edl_types_gen;

    // Lightweight struct to hold wstring characters that are passed
    // through the codegen layer. Would be generated by edlcodgen.exe
    // Raw character bytes only.
    #[derive(Debug, Clone, PartialEq, Default, EdlDerive)]
    #[target_struct(edl_types_gen::WStringT)]
    pub struct WString
    {
        pub wchars: Vec<u16>,
    }
}

// Simulate module and items to be generated by edlcodegen.exe
// Which represent the types the developer used in their .edl file.
mod dev_types {
    use edlcodegen_core::EdlDerive;
    use super::flatbuffer_test;
    use super::edl_types;

    // Simulates an enum generated by edlcodgen.exe
    #[repr(C)]
    #[derive(Debug, Clone, PartialEq, Default, EdlDerive)]
    #[target_enum(flatbuffer_test::Color)]
    pub enum Color {
        #[default]
        Red,
        Green,
        Blue,
    }

    // Simulates a struct generated by edlcodgen.exe
    #[derive(Debug, Clone, PartialEq, Default, EdlDerive)]
    #[target_struct(flatbuffer_test::NestedDataT)]
    pub struct NestedData {
        pub id: u32,
        pub name: String,
        pub active: bool,
        pub values: Vec<f32>,
        pub color: Color,
    }

    // Simulates a struct generated by edlcodgen.exe
    #[derive(Debug, Clone, PartialEq, Default, EdlDerive)]
    #[target_struct(flatbuffer_test::AllTypesT)]
    pub struct AllTypes {
        pub i8_field: i8,
        pub i16_field: i16,
        pub i32_field: i32,
        pub i64_field: i64,
        pub u8_field: u8,
        pub u16_field: u16,
        pub u32_field: u32,
        pub u64_field: u64,
        pub bool_field: bool,
        pub f32_field: f32,
        pub f64_field: f64,
        pub str_field: String,
        pub color_field: Color,
        pub vec_i8: Vec<i8>,
        pub vec_i16: Vec<i16>,
        pub vec_i32: Vec<i32>,
        pub vec_i64: Vec<i64>,
        pub vec_u8: Vec<u8>,
        pub vec_u16: Vec<u16>,
        pub vec_u32: Vec<u32>,
        pub vec_u64: Vec<u64>,
        pub vec_f32: Vec<f32>,
        pub vec_f64: Vec<f64>,
        pub vec_bool: Vec<bool>,
        pub vec_str: Vec<String>,
        pub vec_color: Vec<Color>,
        pub opt_i32: Option<i32>,
        pub opt_str: Option<String>,

        #[boxed_inner_target] // flatbuffer target = Option<Box<NestedDataT>>
        pub opt_nested_struct: Option<NestedData>,

        pub opt_vec_f64: Option<Vec<f64>>,
        pub opt_vec_nested_struct: Option<Vec<NestedData>>,
        pub opt_box_to_same_struct_type: Option<Box<AllTypes>>,
        
        #[boxed_target] // flatbuffer target = Box<NestedDataT>
        pub nested_struct: NestedData,

        pub vec_nested_struct: Vec<NestedData>,

        #[boxed_target] // flatbuffer target = Box<edl_types_gen::WStringT>
        pub wstr: edl_types::WString,

        pub vec_wstr: Vec<edl_types::WString>,
        pub str_arr: [String; 2],
        pub nested_struct_arr: [NestedData; 2],
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_conversion_between_edl_types_and_flatbuffer_types() {
        let nested_data = dev_types::NestedData {
            id: 42,
            name: "Inner Item".to_string(),
            active: true,
            values: vec![0.1, 0.2, 0.3],
            color: dev_types::Color::Green,
        };

        let initial_edl_struct = dev_types::AllTypes {
            i8_field: -8,
            i16_field: -1600,
            i32_field: -32000,
            i64_field: -64000,
            u8_field: 8,
            u16_field: 1600,
            u32_field: 32000,
            u64_field: 64000,
            bool_field: true,
            f32_field: 3.14,
            f64_field: 6.28,
            str_field: "Hello FlatBuffers!".to_string(),
            color_field: dev_types::Color::Red,
            vec_i8: vec![-1, 0, 1],
            vec_i16: vec![-10, 0, 10],
            vec_i32: vec![-100, 0, 100],
            vec_i64: vec![-1000, 0, 1000],
            vec_u8: vec![1, 2, 3],
            vec_u16: vec![10, 20, 30],
            vec_u32: vec![100, 200, 300],
            vec_u64: vec![1000, 2000, 3000],
            vec_f32: vec![1.1, 2.2, 3.3],
            vec_f64: vec![4.4, 5.5, 6.6],
            vec_bool: vec![true, false, true],
            vec_str: vec![
                "foo".to_string(),
                "bar".to_string(),
                "baz".to_string(),
            ],
            vec_color: vec![dev_types::Color::Red, dev_types::Color::Green, dev_types::Color::Blue],
            opt_i32: Some(123),
            opt_str: Some("optional string".to_string()),
            opt_nested_struct: Some(nested_data.clone()),
            opt_vec_f64: Some(vec![0.11, 0.22, 0.33]),
            opt_vec_nested_struct: Some(vec![nested_data.clone()]),
            opt_box_to_same_struct_type: Some(Box::new(dev_types::AllTypes::default())),
            nested_struct: nested_data.clone(),
            vec_nested_struct: vec![nested_data.clone(), nested_data.clone()],
            wstr: edl_types::WString{wchars: vec![11u16, 22u16, 33u16] },
            vec_wstr: vec![edl_types::WString{wchars: vec![11u16, 22u16, 33u16] }],
            str_arr: ["foo".to_string(), "bar".to_string()],
            nested_struct_arr: [nested_data.clone(), nested_data.clone()],
        };

        // Developer type -> Flatbuffer type
        let flatbuffer_struct: flatbuffer_test::AllTypesT = initial_edl_struct.clone().into();

        // Flatbuffer type -> Developer type
        let ending_dev_struct: dev_types::AllTypes = flatbuffer_struct.into();

        // Check that the dev type struct we ended up with is the same as the initial
        // struct to confirm we succeeded the round trip.
        assert_eq!(initial_edl_struct, ending_dev_struct);
    }
}