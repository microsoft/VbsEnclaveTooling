// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

/// Default capacity (in bytes) for new FlatBuffer builders.
const INITIAL_DEFAULT_SIZE_IN_BYTES: usize = 4096;

/// Trait defining the common interface for FlatBuffer-compatible types.
///
/// This trait allows any type implementing it to:
/// - **Pack** itself into a FlatBuffer builder, producing an flatbuffer offset object.
/// - **Unpack** itself from a serialized byte buffer back into a flatbuffer struct/enum.
pub trait FlatbufferPack<'a> {
    /// The generated FlatBuffer table type corresponding to this flatbuffer struct/enum.
    type TableType: flatbuffers::Follow<'a> + 'a;

    /// Packs the native struct into a FlatBuffer builder.
    ///
    /// Returns a `WIPOffset` object pointing to the serialized object within the builder.
    fn pack(
        &self,
        builder: &mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> flatbuffers::WIPOffset<Self::TableType>;

    /// Unpacks the FlatBuffer binary data into a native struct instance.
    ///
    /// # Errors
    /// Returns [`flatbuffers::InvalidFlatbuffer`] if the input buffer is
    /// malformed or missing required fields.
    fn unpack(data: &'a [u8]) -> Result<Self, flatbuffers::InvalidFlatbuffer>
    where
        Self: Sized;
}

/// Convenience helper that packs a FlatBuffer-compatible struct.
///
/// This function builds a FlatBuffer using a default initial buffer size,
/// finishes the buffer, and returns the builder.
pub fn pack_flatbuffer<'a, T: FlatbufferPack<'a>>(
    native: &T,
) -> flatbuffers::FlatBufferBuilder<'a> {
    let mut builder = flatbuffers::FlatBufferBuilder::with_capacity(INITIAL_DEFAULT_SIZE_IN_BYTES);
    let offset = native.pack(&mut builder);
    builder.finish(offset, None);
    builder
}

/// Implements the [`FlatbufferPack`] trait for a native FlatBuffer struct and
/// table pair.
///
/// # Overview
/// This macro bridges the generated native Rust type (e.g., `MyTableT`) and
/// its corresponding FlatBuffer table type (e.g., `MyTable<'a>`).
///
/// It enables both packing and unpacking to be used generically across the
/// framework without writing boilerplate implementations.
///
/// # Parameters
/// - `$native_fb_stuct`: The generated native struct type (usually `<Name>T`)
///   that represents the FlatBuffer object in Rust.
/// - `$flatbuffer_table_obj`: The corresponding FlatBuffer table type (usually
///   `<Name<'a>>`) generated by the FlatBuffers compiler.
#[allow(unused_macros)]
#[macro_export]
macro_rules! impl_flatbuffer_pack {
    ($native_fb_stuct:ty, $flatbuffer_table_obj:ty) => {
        impl<'a> FlatbufferPack<'a> for $native_fb_stuct {
            type TableType = $flatbuffer_table_obj;
            fn pack(
                &self,
                builder: &mut flatbuffers::FlatBufferBuilder<'a>,
            ) -> flatbuffers::WIPOffset<$flatbuffer_table_obj> {
                self.pack(builder)
            }

            fn unpack(data: &'a [u8]) -> Result<Self, flatbuffers::InvalidFlatbuffer> {
                flatbuffers::root::<$flatbuffer_table_obj>(data).map(|root| root.unpack())
            }
        }
    };
}
