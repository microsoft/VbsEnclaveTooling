// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
// File used for testing purposes

enclave
{   
    import "CodeGenTestTypes.edl";

    // Anonymous enum
    enum
    {
        value2 = 50,
    };

    struct NestedStructWithArray
    {
        int64_t array1[value1];
    };

    struct NestedStructWithVectors
    {
        vector<NestedStructWithArray> value_in_nested_struct;
    };

    struct TestStruct1
    {
        bool bool_val;
        int8_t int8_val;
        int16_t int16_val;
        int32_t int32_val;
        int64_t int64_val;
        uint8_t uint8_val;
        uint16_t uint16_val;
        uint32_t uint32_val;
        uint64_t uint64_val;
        
        HexEnum hex_val;
        DecimalEnum deci_val;
        int64_t array1[5];

        HRESULT result;
    };

    struct TestStruct2
    {
        NestedStructWithArray field1;
        NestedStructWithVectors field2;
    };

    struct TestStruct3
    {
        TestStruct1 field1;
        TestStruct2 field2;
        vector<TestStruct2> field3;
        TestStruct1 field4[value2];
        TestStruct2 field5;
    };

    struct StructWithOptionals
    {
        optional<NestedStructWithOptionals> nested_struct_opt;
    };

    struct NestedStructWithOptionals
    {
        optional<int32_t> int32_opt;
        optional<DecimalEnum> deci_opt;
        optional<TestStruct1> struct_opt;
    };

    // Host to enclave functions
    trusted
    {
        HRESULT TestPassingPrimitivesAsValues_To_Enclave(
            bool bool_val,
            DecimalEnum enum_val,
            int8_t int8_val);

        HRESULT TestPassingPrimitivesAsInOutValues_To_Enclave(
            [in, out] bool bool_val,
            [in, out] HexEnum enum_val,
            [in, out] int8_t int8_val);

        HRESULT TestPassingPrimitivesAsOutValues_To_Enclave(
            [out] bool bool_val,
            [out] HexEnum enum_val,
            [out] int8_t int8_val);

        // Optionals should have an in or out direction. Otherwise the codegen layer will see them as [in] parameters.
        HRESULT TestPassingPrimitivesAsInOptionals_To_Enclave(
            [in] optional<uint8_t> uint8_val,
            [in] optional<uint16_t> uint16_val,
            [in] optional<uint32_t> uint32_val,
            [in] optional<uint32_t> empty_uint32_val);

        // Optionals should have an in or out direction. Otherwise the codegen layer will see them as [in] parameters.
        HRESULT TestPassingPrimitivesAsInOutOptionals_To_Enclave(
            [in, out] optional<int8_t> int8_val,
            [in, out] optional<int16_t> int16_val,
            [in, out] optional<int32_t> int32_val);

        // Optionals should have an in or out direction. Otherwise the codegen layer will see them as [in] parameters.
        HRESULT TestPassingPrimitivesAsOutOptionals_To_Enclave(
            [out] optional<bool> bool_val,
            [out] optional<DecimalEnum> enum_val,
            [out] optional<uint64_t> uint64_val); 

        // Example of returning a optional. Marshalling works the same way for primitive so we only need a test
        // for one.
        optional<int32_t> ReturnInt32Opt_From_Enclave();

        uint64_t ReturnUint64Val_From_Enclave();

        // Returning a more complex struct
        StructWithNoOptionals ReturnStructWithValues_From_Enclave();

        StructWithNoOptionals ComplexPassingOfTypes_To_Enclave(
            StructWithNoOptionals arg1,
            [in, out]StructWithNoOptionals arg2,
            [out] optional<StructWithNoOptionals> arg3,
            [out] StructWithNoOptionals arg4,
            optional<StructWithNoOptionals> arg5_empty, // pass empty value
            optional<StructWithNoOptionals> arg6,
            [in, out] optional<StructWithNoOptionals> arg7,
            [out] optional<uint64_t> uint64_val);
        
        StructWithOptionals ComplexPassingOfTypesThatContainOptionals_To_Enclave(
            [in] optional<StructWithOptionals> arg1_empty, // pass empty value
            [in] optional<StructWithOptionals> arg2,
            [in, out] optional<StructWithOptionals> arg3,
            [out] optional<StructWithOptionals> arg4,
            [in, out] vector<StructWithOptionals> arg5,
            [in, out] StructWithOptionals arg6[2]);

        void ReturnNoParams_From_Enclave();

        vector<TestStruct1> ReturnObjectInVector_From_Enclave();

        HRESULT PassingPrimitivesInVector_To_Enclave(
            [in] vector<int8_t> arg1,
            [in] vector<int16_t> arg2,
            [in] vector<int32_t> arg3,
            [in, out] vector<int8_t> arg4,
            [in, out] vector<int16_t> arg5,
            [in, out] vector<int32_t> arg6,
            [out] vector<int8_t> arg7,
            [out] vector<int16_t> arg8,
            [out] vector<int32_t> arg9);

        TestStruct2 ComplexPassingOfTypesWithVectors_To_Enclave(
            TestStruct1 arg1,
            [in, out]TestStruct2 arg2,
            [out] TestStruct3 arg3,
            [in] vector<TestStruct1> arg4,
            [in, out] vector<TestStruct2> arg5,
            [out] vector<TestStruct3> arg6);

        string PassingStringTypes_To_Enclave(
            string arg1,
            [in, out]string arg2,
            [out] string arg3,
            [in] vector<string> arg4,
            [in, out] vector<string> arg5,
            [out] vector<string> arg6);

        wstring PassingWStringTypes_To_Enclave(
            wstring arg1,
            [in, out]wstring arg2,
            [out] wstring arg3,
            [in] vector<wstring> arg4,
            [in, out] vector<wstring> arg5,
            [out] vector<wstring> arg6);

        NestedStructWithArray PassingArrayTypes_To_Enclave(
            TestStruct1 arg1[2],
            [in, out]string arg2[2],
            [out] wstring arg3[2],
            [in, out]TestStruct2 arg4[2],
            [out]TestStruct3 arg5[2]);

        // Vtl1 can't test vtl0 callbacks unless we start them from vtl0. These functions
        // are just used to allow us to start the callback tests.
        HRESULT Start_TestPassingPrimitivesAsValues_To_HostApp_Callback_Test();
        HRESULT Start_TestPassingPrimitivesAsInOutValues_To_HostApp_Callback_Test();
        HRESULT Start_TestPassingPrimitivesAsOutValues_To_HostApp_Callback_Test();
        HRESULT Start_TestPassingPrimitivesAsInOptionals_To_HostApp_Callback_Test();
        HRESULT Start_TestPassingPrimitivesAsInOutOptionals_To_HostApp_Callback_Test();
        HRESULT Start_TestPassingPrimitivesAsOutOptionals_To_HostApp_Callback_Test(); 
        HRESULT Start_ReturnInt32Opt_From_HostApp_Callback_Test();
        HRESULT Start_ReturnUint64Val_From_HostApp_Callback_Test();
        HRESULT Start_ReturnStructWithValues_From_HostApp_Callback_Test();
        HRESULT Start_ComplexPassingOfTypes_To_HostApp_Callback_Test();
        HRESULT Start_ComplexPassingOfTypesThatContainOptionals_To_HostApp_Callback_Test();
        void Start_ReturnNoParams_From_HostApp_Callback_Test();
        HRESULT Start_ReturnObjectInVector_From_HostApp_Callback_Test();
        HRESULT Start_PassingPrimitivesInVector_To_HostApp_Callback_Test();
        HRESULT Start_ComplexPassingOfTypesWithVectors_To_HostApp_Callback_Test();
        HRESULT Start_PassingStringTypes_To_HostApp_Callback_Test();
        HRESULT Start_PassingWStringTypes_To_HostApp_Callback_Test();
        HRESULT Start_PassingArrayTypes_To_HostApp_Callback_Test();
        HRESULT Start_Throw_Winrt_Exception_From_Host_Test();
    };

    // Functions are the same but these are for the opposite direction.
    // (Enclave to host).
    untrusted
    {
        HRESULT TestPassingPrimitivesAsValues_To_HostApp(
            bool bool_val,
            DecimalEnum enum_val,
            int8_t int8_val);

        HRESULT TestPassingPrimitivesAsInOutValues_To_HostApp(
            [in, out] bool bool_val,
            [in, out] HexEnum enum_val,
            [in, out] int8_t int8_val);

        HRESULT TestPassingPrimitivesAsOutValues_To_HostApp(
            [out] bool bool_val,
            [out] HexEnum enum_val,
            [out] int8_t int8_val);

        // Optionals should have an in or out direction. Otherwise the codegen layer will see them as [in] parameters.
        HRESULT TestPassingPrimitivesAsInOptionals_To_HostApp(
            [in] optional<uint8_t> uint8_val,
            [in] optional<uint16_t> uint16_val,
            [in] optional<uint32_t> uint32_val,
            [in] optional<uint32_t> empty_uint32_val); // pass empty value

        // Optionals should have an in or out direction. Otherwise the codegen layer will see them as [in] parameters.
        HRESULT TestPassingPrimitivesAsInOutOptionals_To_HostApp(
            [in, out] optional<int8_t> int8_val,
            [in, out] optional<int16_t> int16_val,
            [in, out] optional<int32_t> int32_val);

        // Optionals should have an in or out direction. Otherwise the codegen layer will see them as [in] parameters.
        HRESULT TestPassingPrimitivesAsOutOptionals_To_HostApp(
            [out] optional<bool> bool_val,
            [out] optional<DecimalEnum> enum_val,
            [out] optional<uint64_t> uint64_val); 

        // Example of returning a optional. Marshalling works the same way for primitive so we only need a test
        // for one.
        optional<int32_t> ReturnInt32Opt_From_HostApp();

        uint64_t ReturnUint64Val_From_HostApp();

        // Returning a more complex struct
        StructWithNoOptionals ReturnStructWithValues_From_HostApp();

        void ReturnNoParams_From_HostApp();

        StructWithNoOptionals ComplexPassingOfTypes_To_HostApp(
            StructWithNoOptionals arg1,
            [in, out]StructWithNoOptionals arg2,
            [out] optional<StructWithNoOptionals> arg3,
            [out] StructWithNoOptionals arg4,
            optional<StructWithNoOptionals> arg5_empty, // pass empty value
            optional<StructWithNoOptionals> arg6,
            [in, out] optional<StructWithNoOptionals> arg7,
            [out] optional<uint64_t> uint64_val);

        StructWithOptionals ComplexPassingOfTypesThatContainOptionals_To_HostApp(
            [in] optional<StructWithOptionals> arg1_empty, // pass empty value
            [in] optional<StructWithOptionals> arg2,
            [in, out] optional<StructWithOptionals> arg3,
            [out] optional<StructWithOptionals> arg4,
            [in, out] vector<StructWithOptionals> arg5,
            [in, out] StructWithOptionals arg6[2]);

        vector<TestStruct1> ReturnObjectInVector_From_HostApp();

        HRESULT PassingPrimitivesInVector_To_HostApp(
            [in] vector<int8_t> arg1,
            [in] vector<int16_t> arg2,
            [in] vector<int32_t> arg3,
            [in, out] vector<int8_t> arg4,
            [in, out] vector<int16_t> arg5,
            [in, out] vector<int32_t> arg6,
            [out] vector<int8_t> arg7,
            [out] vector<int16_t> arg8,
            [out] vector<int32_t> arg9);

        TestStruct2 ComplexPassingOfTypesWithVectors_To_HostApp(
            TestStruct1 arg1,
            [in, out]TestStruct2 arg2,
            [out] TestStruct3 arg3,
            [in] vector<TestStruct1> arg4,
            [in, out] vector<TestStruct2> arg5,
            [out] vector<TestStruct3> arg6);

        string PassingStringTypes_To_HostApp(
            string arg1,
            [in, out]string arg2,
            [out] string arg3,
            [in] vector<string> arg4,
            [in, out] vector<string> arg5,
            [out] vector<string> arg6);

        wstring PassingWStringTypes_To_HostApp(
            wstring arg1,
            [in, out]wstring arg2,
            [out] wstring arg3,
            [in] vector<wstring> arg4,
            [in, out] vector<wstring> arg5,
            [out] vector<wstring> arg6);

        NestedStructWithArray PassingArrayTypes_To_HostApp(
            TestStruct1 arg1[2],
            [in, out]string arg2[2],
            [out] wstring arg3[2],
            [in, out]TestStruct2 arg4[2],
            [out]TestStruct3 arg5[2]);

        void Throw_Winrt_Exception_From_Host();
    };
};
