// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

enclave
{
    // Host to enclave functions
    trusted
    {
        HRESULT RunTaskpoolExample(uint32_t thread_count);
        
        HRESULT RunEncryptionKeyExample_CreateEncryptionKey(
            uint32_t activity_level,
            wstring log_file_path,
            [out] vector<uint8_t> secured_encryption_key_bytes
            );

        HRESULT RunEncryptionKeyExample_LoadEncryptionKey(
            vector<uint8_t> secured_encryption_key_bytes,
            wstring data_to_encrypt,
            bool is_to_be_encrypted, // Controls if the Load flow is used for encryption or decryption
            uint32_t activity_level,
            wstring log_file_path,
            [out] vector<uint8_t> resealed_encryption_key_bytes,
            [in, out] vector<uint8_t> encrypted_input_bytes,
            [in, out] vector<uint8_t> tag,
            [out] wstring decrypted_input_bytes
            );

        HRESULT RunEncryptionKeyExample_LoadEncryptionKeyThreadpool(
            vector<uint8_t> secured_encryption_key_bytes,
            wstring data_to_encrypt_1,
            wstring data_to_encrypt_2,
            bool is_to_be_encrypted, // Controls if the Load flow is used for encryption or decryption
            uint32_t activity_level,
            wstring log_file_path,
            [out] vector<uint8_t> resealed_encryption_key_bytes,
            [in, out] vector<uint8_t> encrypted_input_bytes_1,
            [in, out] vector<uint8_t> encrypted_input_bytes_2,
            [in, out] vector<uint8_t> tag1,
            [in, out] vector<uint8_t> tag2,
            [out] wstring decrypted_input_bytes_1,
            [out] wstring decrypted_input_bytes_2
            );

        HRESULT MyEnclaveCreateUserBoundKey(
            wstring helloKeyName,
            wstring pinMessage,
            uintptr_t windowId,
            uint32_t keyCredentialCreationOption,
            [out] vector<uint8_t> securedEncryptionKeyBytes
            );

        HRESULT MyEnclaveLoadUserBoundKeyAndEncryptData(
            wstring helloKeyName,
            wstring pinMessage,
            uintptr_t windowId,
            vector<uint8_t> secured_encryption_key_bytes,
            wstring inputData,
            [out] vector<uint8_t> combinedOutputData,
            [out] bool needsReseal,
            [out] vector<uint8_t> resealedEncryptionKeyBytes
            );

        HRESULT MyEnclaveLoadUserBoundKeyAndDecryptData(
            wstring helloKeyName,
            wstring pinMessage,
            uintptr_t windowId,
            vector<uint8_t> secured_encryption_key_bytes,
            vector<uint8_t> combinedInputData,
            [out] wstring decryptedData,
            [out] bool needsReseal,
            [out] vector<uint8_t> resealedEncryptionKeyBytes
            );

        // Asymmetric key functions for digital signatures
        HRESULT MyEnclaveCreateAsymmetricUserBoundKey(
            wstring keyName,
            wstring pinMessage,
            uintptr_t windowId,
            uint32_t keyCredentialCreationOption,
            [out] vector<uint8_t> securedPrivateKeyBytes,
            [out] vector<uint8_t> publicKeyBytes
        );        HRESULT MyEnclaveSignDataWithUserBoundKey(
            wstring keyName,
            wstring pinMessage,
            uintptr_t windowId,
            vector<uint8_t> securedPrivateKeyBytes,
            wstring dataToSign,
            [out] vector<uint8_t> signature,
            [out] bool needsReseal,
            [out] vector<uint8_t> resealedPrivateKeyBytes
        );        HRESULT MyEnclaveVerifySignatureWithPublicKey(
            vector<uint8_t> publicKeyBytes,
            wstring dataToVerify,
            vector<uint8_t> signature,
            [out] bool isValid
        );
    };
};
